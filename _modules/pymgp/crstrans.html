
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pymgp.crstrans &#8212; pyMGP 0.9 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=049aceee"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/pymgp/crstrans';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">pyMGP 0.9 documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../usage.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../release.html">
    Release notes
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../usage.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../release.html">
    Release notes
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">pymgp.crstrans</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for pymgp.crstrans</h1><div class="highlight"><pre>
<span></span><span class="c1"># coding: utf-8</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Coordinate conversions and transformations.</span>

<span class="sd">This module provides basic functions for coordinate conversions and transformations</span>
<span class="sd">for Earth Centered Earth Fixed Cartesian coordinates, local topocentric </span>
<span class="sd">coordinates, and ellipsoidal geodetic latitude, longitude and height. </span>

<span class="sd">Coordinate conversions in ECEF reference frame</span>

<span class="sd">- xyz2plh       Cartesian coordinates to Ellipsoidal coordinates</span>
<span class="sd">- plh2xyz       Ellipsoidal coordinates to Cartesian coordinates</span>
<span class="sd">- inqell        Semi-major axis, flattening and GM for various ellipsoids</span>
<span class="sd">- setell        Set the current ellipsoid</span>

<span class="sd">Curvilinear coordinate conversions</span>

<span class="sd">- ellcurvature  Multiplication factors to convert latitude and longitude angles to meters.</span>

<span class="sd">Coordinate transformations between ECEF and local (topocentric) reference frames</span>

<span class="sd">- xyz2neu       Cartesian coordinates to local coordinates (North,East,Up)</span>
<span class="sd">- neu2xyz       Local coordinates (North,East,Up) to Cartesian coordinates</span>
<span class="sd">- xyz2zas       Cartesian coordinates to zenith angle, azimuth and distance</span>
<span class="sd">- zas2xyz       Zenith angle, azimuth and distance to Cartesian coordinates</span>

<span class="sd">- ellnormal     Return unit normal vector perpendicular to ellipsoid</span>
<span class="sd">- ellrotmatrix  Rotation matrix to transform between ECEF and topocentric frames </span>
<span class="sd">- covtransform  Transform and reformat (compact) co-variance matrices</span>

<span class="sd">Print functions</span>

<span class="sd">- printcrd      Print a table with coordinates and optional co-variances</span>
<span class="sd">- printxyz      Print array with cartesian coordinates</span>
<span class="sd">- printplh      Print array with geodetic/ellipsoidal coordinates </span>
<span class="sd">- deg2dms       Convert latitude/longitude to degree, minute, second notation</span>

<span class="sd">The functions are optimized for Python&#39;s numpy library, it accepts mostly numpy</span>
<span class="sd">alike ndarrays with the coordinates (usually three) in the last axis.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Hans van der Marel&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2022-2024, Hans van der Marel, Delft University of Technology.&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Hans van der Marel&quot;</span><span class="p">,</span> <span class="s2">&quot;Simon van Diepen&quot;</span><span class="p">]</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;License Name and Info&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.9.0&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Hans van der Marel&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;h.vandermarel@tudelft.nl&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s2">&quot;development&quot;</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created:    20 Aug 2022 by Hans van der Marel from crsutil</span>
<span class="sd">Modified:   20 Aug 2022 by Hans van der Marel</span>
<span class="sd">             - inqell, xyz2plh and plh2xyz from crsutil with minor to major changes</span>
<span class="sd">             - new functions ellnormal, xyz2neu, neu2xyx, xyz2zas, zas2xyz</span>
<span class="sd">             - rewrite of the docstrings, reinsert original comments from Matlab</span>
<span class="sd">             - major style improvements, modified options, more Pythonic</span>
<span class="sd">            16 Jul 2024 by Hans van der Marel</span>
<span class="sd">             - new functions ellrotate and covtransform</span>
<span class="sd">             - many major and minor changes to other functions</span>
<span class="sd">            18 Jul 2024 by Hans van der Marel</span>
<span class="sd">             - Minor changes to the docstrings</span>
<span class="sd">             - Optional output of rotation matrix in xyz2neu and neu2xyz</span>
<span class="sd">            19 Jul 2024 by Hans van der Marel</span>
<span class="sd">             - Modified ellnormal, improved docstrings, fix bug in normalize option, </span>
<span class="sd">               added assertion on mode</span>
<span class="sd">            22 Jul 2024 by Hans van der Marel</span>
<span class="sd">             - port of prtcrd to Python, renamed to printcrd </span>
<span class="sd">             - added functions printxyz, printplh, deg2dms</span>
<span class="sd">            27 Jul 2024 by Hans van der Marel</span>
<span class="sd">             - new functions setell and ellcurvature</span>
<span class="sd">             - changed default for ellipsoid in inqell to &#39;current&#39;</span>
<span class="sd">             - changes to the docstrings</span>
<span class="sd">            22 Aug 2024 by Hans van der Marel</span>
<span class="sd">             - Major edits to the docstrings to facilitate sphynx</span>

<span class="sd">The functions are based the crsutil Malab toolbox written by Hans van der Marel </span>
<span class="sd">starting in 1995. Some of the functions were ported to Python in November 2020</span>
<span class="sd">with the help of Ullas Rajvanshi and Simon van Diepen, and became part of the </span>
<span class="sd">crsutil.py module (with only a subset of the Matlab crsutil toolbox).</span>

<span class="sd">In August 2022 the crsutil.py was split into two new modules, crstrans.py and</span>
<span class="sd">satorb.py, with crstrans.py including new functions for local reference frames,</span>
<span class="sd">and a full rewrite, with improved docstrings, reinsertion of original comments,</span>
<span class="sd">major style improvements, modified options, more Pythonic.</span>

<span class="sd">Copyright 2022-2024, Hans van der Marel, Delft University of Technology. </span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Importing the Libraries</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#                      GEODETIC FROM/TO CARTESIAN COORDINATES </span>
<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1">#   xyz2plh      - Convert Cartesian coordinates into Ellipsoidal coordinates</span>
<span class="c1">#   plh2xyz      - Convert Ellipsoidal coordinates into Cartesian coordinates</span>
<span class="c1">#   inqell       - Semi-major axis, flattening and GM for various ellipsoids</span>
<span class="c1">#   setell       - Set the current ellipsoid</span>

<span class="c1"># Define a dict with the Semi-major axis, inverse flattening and GM for various ellipsoids</span>

<span class="n">ELLIPSOID_PARAMETERS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;AIRY&#39;</span><span class="p">:</span>          <span class="p">[</span><span class="mf">6377563.396</span><span class="p">,</span> <span class="mf">299.324964</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> 
    <span class="s1">&#39;BESSEL&#39;</span><span class="p">:</span>        <span class="p">[</span><span class="mf">6377397.155</span><span class="p">,</span> <span class="mf">299.1528128</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span> 
    <span class="s1">&#39;CLARKE&#39;</span><span class="p">:</span>        <span class="p">[</span><span class="mf">6378249.145</span><span class="p">,</span> <span class="mf">293.465</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
    <span class="s1">&#39;INTERNATIONAL&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">6378388.0</span><span class="p">,</span> <span class="mf">297.00</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">],</span>
    <span class="s1">&#39;HAYFORD&#39;</span><span class="p">:</span>       <span class="p">[</span><span class="mf">6378388.0</span><span class="p">,</span> <span class="mf">297.00</span><span class="p">,</span> <span class="mf">3.986329e14</span><span class="p">],</span>
    <span class="s1">&#39;GRS80&#39;</span><span class="p">:</span>         <span class="p">[</span><span class="mf">6378137.0</span><span class="p">,</span> <span class="mf">298.257222101</span><span class="p">,</span> <span class="mf">3.986005e14</span><span class="p">],</span>
    <span class="s1">&#39;WGS84&#39;</span><span class="p">:</span>         <span class="p">[</span><span class="mf">6378137.0</span><span class="p">,</span> <span class="mf">298.257223563</span><span class="p">,</span> <span class="mf">3.986005e14</span><span class="p">],</span>
    <span class="s1">&#39;current&#39;</span><span class="p">:</span>       <span class="p">[</span><span class="mf">6378137.0</span><span class="p">,</span> <span class="mf">298.257223563</span><span class="p">,</span> <span class="mf">3.986005e14</span><span class="p">]</span>
<span class="p">}</span>
<span class="n">CURRENT_ELLIPSOID</span> <span class="o">=</span> <span class="s1">&#39;WGS84&#39;</span>

       
<div class="viewcode-block" id="xyz2plh">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.xyz2plh.html#pymgp.crstrans.xyz2plh">[docs]</a>
<span class="k">def</span> <span class="nf">xyz2plh</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">=</span><span class="s1">&#39;current&#39;</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;Bowring&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Cartesian XYZ coordinates to Ellipsoidal latitude, longitude and height coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xyz : array_like with shape (...,3) </span>
<span class="sd">        Cartesian XYZ coordinates. </span>
<span class="sd">    ellipsoid : str or list of floats, default = &#39;current&#39;</span>
<span class="sd">        Text string with the name of the ellipse or a list ``[a, 1/f]`` with the semi-major </span>
<span class="sd">        axis `a` and inverse flattening `1/f`. The current ellipsoid can be set by</span>
<span class="sd">        `setell`. Default for the current ellips is &#39;WGS-84&#39;.</span>
<span class="sd">    method : {&#39;Bowring&#39;, &#39;iterative&#39;}, default = &#39;Bowring&#39;</span>
<span class="sd">        Bowring&#39;s method is uded by default. Bowring&#39;s method is faster, but can </span>
<span class="sd">        only be used on the surface of the Earth. The iterative method is slower </span>
<span class="sd">        and less precise on the surface of the earth, but should be used above </span>
<span class="sd">        10-20 km of altitude.</span>
<span class="sd">    unit : {&#39;rad&#39;, &#39;deg&#39;},  default = &#39;rad&#39;</span>
<span class="sd">        Units for the output latitude and longitude.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    plh : ndarray with the same shape (...,3) as `xyz`</span>
<span class="sd">        Ellipsoidal coordinates (geographic latitude, longitude and height above the ellipsoid).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    plh2xyz, inqell, setell</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; plh = xyz2plh([3925375.1007 , 274488.9665, 5002803.3455], unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(np.round(plh,4))          </span>
<span class="sd">    [52.  4.  0.]</span>

<span class="sd">    &gt;&gt;&gt; plhin = [ [50, 0, 0], [51, 1, -4], [52, 4, 2], [53, 3, 3] ]</span>
<span class="sd">    &gt;&gt;&gt; xyz = plh2xyz(plhin, unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plh = xyz2plh(xyz, unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print( np.max(np.abs(plh-plhin)) &lt; 1e-9)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span> 
    
    <span class="c1"># Force input array to ndarray and check the shape</span>
    
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">,</span> <span class="s2">&quot;Cartesian vector xyz must have three coordinates (XYZ).&quot;</span> 
    <span class="k">assert</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rad&#39;</span> <span class="p">,</span><span class="s1">&#39;deg&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported unit </span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">.&quot;</span>
  
    <span class="c1"># excentricity e(squared), semi-major (a) and semi - minor (b) axis</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">GM</span> <span class="o">=</span> <span class="n">inqell</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">)</span>
    
    <span class="n">e2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">f</span> <span class="o">-</span> <span class="n">f</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">f</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span>

    <span class="c1"># compute the radius, geographic latitude and N</span>
    
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;iterative&#39;</span><span class="p">:</span>
        <span class="c1"># compute phi via iteration</span>
        <span class="n">Np</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan</span><span class="p">((</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">e2</span> <span class="o">*</span> <span class="n">Np</span><span class="p">)</span> <span class="o">/</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">e2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">Np</span> <span class="o">=</span> <span class="n">N</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># compute phi using B.R.Bowring&#39;s equation (default method)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="p">,</span> <span class="n">r</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">e2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">e2</span><span class="p">)</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span><span class="p">,</span> <span class="n">r</span> <span class="o">-</span> <span class="p">(</span><span class="n">e2</span> <span class="o">*</span> <span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">e2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        
    <span class="c1"># assemble </span>

    <span class="n">plh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span> <span class="n">phi</span><span class="p">,</span> 
                     <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> 
                     <span class="n">r</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span> <span class="o">-</span> <span class="n">N</span>  <span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
        <span class="n">plh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span> <span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="p">,</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="p">,</span> <span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> 

    <span class="k">return</span> <span class="n">plh</span></div>



<div class="viewcode-block" id="plh2xyz">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.plh2xyz.html#pymgp.crstrans.plh2xyz">[docs]</a>
<span class="k">def</span> <span class="nf">plh2xyz</span><span class="p">(</span><span class="n">plh</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">=</span><span class="s1">&#39;current&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert ellipsoidal coordinates (latitude, longitude and height) to Cartesian coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    plh : array_like shape (...,3) </span>
<span class="sd">        Ellipsoidal coordinates (geographic latitude, longitude and height above the ellipsoid).</span>
<span class="sd">    ellipsoid : str or list of floats, default = &#39;current&#39;</span>
<span class="sd">        Text string with the name of the ellipse or a list ``[a, 1/f]`` with the semi-major </span>
<span class="sd">        axis `a` and inverse flattening `1/f`. The current ellipsoid can be set by</span>
<span class="sd">        `setell`. Default for the current ellips is &#39;WGS-84&#39;. </span>
<span class="sd">    unit : {&#39;rad&#39;, &#39;deg&#39;},  default = &#39;rad&#39;</span>
<span class="sd">        Units for the input latitude and longitude.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xyz : ndarray with the same shape (...,3) as `plh`</span>
<span class="sd">        Cartesian XYZ coordinates.</span>
<span class="sd">        </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    xyz2plh, inqell, setell</span>
<span class="sd">           </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; xyz = plh2xyz([52, 4, 0], unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(np.round(xyz,4))</span>
<span class="sd">    [3925375.1007  274488.9665 5002803.3455]</span>

<span class="sd">    &gt;&gt;&gt; plhin = [ [50, 0, 0], [51, 1, -4], [52, 4, 2], [53, 3, 3] ]</span>
<span class="sd">    &gt;&gt;&gt; xyz = plh2xyz(plhin, unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plh = xyz2plh(xyz, unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print( np.max(np.abs(plh-plhin)) &lt; 1e-9)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span> 

    <span class="c1"># Force input array to ndarray, check the shape, optionally convert units</span>
    
    <span class="n">plh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">plh</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">plh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">,</span> <span class="s2">&quot;Ellipsoidal coordinate vector(s) plh must have three coordinates (Latitude, longitude, height).&quot;</span> 
    <span class="k">assert</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rad&#39;</span> <span class="p">,</span><span class="s1">&#39;deg&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported unit </span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
        <span class="n">plh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span> <span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span> <span class="p">,</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span> <span class="p">,</span> <span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> 
  
    <span class="c1"># excentricity e(squared) and semi - minor axis</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">GM</span> <span class="o">=</span> <span class="n">inqell</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">)</span>   
    <span class="n">e2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">f</span> <span class="o">-</span> <span class="n">f</span> <span class="o">**</span> <span class="mi">2</span>
    
    <span class="c1"># Produce the result</span>
    
    <span class="n">N</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">e2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span>
        <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
        <span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
        <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="n">e2</span> <span class="o">*</span> <span class="n">N</span> <span class="o">+</span> <span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="p">)</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">xyz</span></div>



<div class="viewcode-block" id="inqell">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.inqell.html#pymgp.crstrans.inqell">[docs]</a>
<span class="k">def</span> <span class="nf">inqell</span><span class="p">(</span><span class="n">ellipsoid</span><span class="o">=</span><span class="s1">&#39;current&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Semi-major axis, flattening and GM for various ellipsoids.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ellipsoid: str or list of floats, default = &#39;current&#39;</span>
<span class="sd">        Text string with the name of the ellipse or a list ``[a, 1/f]`` or ``[a, 1/f, GM]``  </span>
<span class="sd">        with the semi-major axis `a` , inverse flattening `1/f` and optionally `GM`. </span>
<span class="sd">        The current ellipsoid can be set by `setell`. Default for the current ellips is </span>
<span class="sd">        &#39;WGS-84&#39;. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a, f, GM: float</span>
<span class="sd">        Semi-major axis `a`, flattening `f` and `GM`.</span>
<span class="sd">           </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    setell, xyz2plh, plh2xyz</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a, f, GM = inqell()</span>
<span class="sd">    &gt;&gt;&gt; print(a,1/f)</span>
<span class="sd">    6378137.0 298.257223563</span>

<span class="sd">    &gt;&gt;&gt; a, f, GM = inqell(&#39;GRS80&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(a,1/f)</span>
<span class="sd">    6378137.0 298.257222101</span>

<span class="sd">    &gt;&gt;&gt; a, f, _ = inqell([a, 1/f])</span>
<span class="sd">    &gt;&gt;&gt; print(a,1/f)</span>
<span class="sd">    6378137.0 298.257222101</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span> 

    <span class="k">global</span> <span class="n">ELLIPSOID_PARAMETERS</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ELLIPSOID_PARAMETERS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">)</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown ellipsoid </span><span class="si">{</span><span class="n">ellipsoid</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">finv</span><span class="p">,</span> <span class="n">GM</span> <span class="o">=</span> <span class="n">ELLIPSOID_PARAMETERS</span><span class="p">[</span><span class="n">ellipsoid</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">finv</span><span class="p">,</span> <span class="n">GM</span>  <span class="o">=</span> <span class="n">ellipsoid</span> 
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">finv</span> <span class="o">=</span> <span class="n">ellipsoid</span>
            <span class="n">GM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;ellipsoid must be a text string, or a list with 2 or 3 elements.&quot;</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;ellipsoid must be a text string, or a list with 2 or 3 elements.&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">finv</span><span class="p">,</span> <span class="n">GM</span></div>


<div class="viewcode-block" id="setell">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.setell.html#pymgp.crstrans.setell">[docs]</a>
<span class="k">def</span> <span class="nf">setell</span><span class="p">(</span><span class="n">ellipsoid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set current ellipsoid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ellipsoid : None or str or list of floats, default = None</span>
<span class="sd">        If None returns the name of the current ellipsoid, if str set the </span>
<span class="sd">        current ellipsoid to one given in str, if list of floats ``[a, 1/f]`` </span>
<span class="sd">        or ``[a, 1/f, GM]`` set a user specified ellipsoid with semi-major axis</span>
<span class="sd">        `a` , inverse flattening `1/f` and optionally `GM`. </span>
<span class="sd">        The current ellipsoid is by default &#39;WGS-84&#39;. </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    current_ellipsoid : str</span>
<span class="sd">        Name of the current ellipsoid.</span>
<span class="sd">           </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    inqell</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; setell()</span>
<span class="sd">    Current ellipsoid: WGS84</span>
<span class="sd">    &#39;WGS84&#39;</span>

<span class="sd">    &gt;&gt;&gt; setell(&#39;GRS80&#39;)</span>
<span class="sd">    &#39;GRS80&#39;</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span> 

    <span class="k">global</span> <span class="n">CURRENT_ELLIPSOID</span><span class="p">,</span> <span class="n">ELLIPSOID_PARAMETERS</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ELLIPSOID_PARAMETERS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">)</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown ellipsoid </span><span class="si">{</span><span class="n">ellipsoid</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
        <span class="n">CURRENT_ELLIPSOID</span> <span class="o">=</span> <span class="n">ellipsoid</span>
        <span class="n">ELLIPSOID_PARAMETERS</span><span class="p">[</span><span class="s1">&#39;current&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ELLIPSOID_PARAMETERS</span><span class="p">[</span><span class="n">ellipsoid</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">finv</span><span class="p">,</span> <span class="n">GM</span>  <span class="o">=</span> <span class="n">ellipsoid</span> 
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">finv</span> <span class="o">=</span> <span class="n">ellipsoid</span>
            <span class="n">GM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;ellipsoid must be a text string, or a list with 2 or 3 elements.&quot;</span><span class="p">)</span> 
        <span class="n">CURRENT_ELLIPSOID</span> <span class="o">=</span> <span class="s1">&#39;user_defined&#39;</span>
        <span class="n">ELLIPSOID_PARAMETERS</span><span class="p">[</span><span class="s1">&#39;current&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span> <span class="n">a</span><span class="p">,</span> <span class="n">finv</span><span class="p">,</span> <span class="n">GM</span> <span class="p">]</span>
    <span class="k">elif</span> <span class="n">ellipsoid</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Current ellipsoid:&#39;</span><span class="p">,</span> <span class="n">CURRENT_ELLIPSOID</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">AssertionError</span><span class="p">(</span><span class="s2">&quot;ellipsoid must be a text string, or a list with 2 or 3 elements, or None&quot;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">CURRENT_ELLIPSOID</span></div>



<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#                 CONVERSION TO/FROM LOCAL TOPOCENTRIC COORDINATES </span>
<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1">#   xyz2neu      - Cartesian XYZ coordinates to local coordinates (North,East,Up)</span>
<span class="c1">#   neu2xyz      - Local coordinates (North,East,Up) to Cartesian (XYZ coordinates)</span>
<span class="c1">#</span>
<span class="c1">#   xyz2zas      - Cartesian coordinates to Zenith angle, azimuth and distance</span>
<span class="c1">#   zas2xyz      - Zenith angle, azimuth and distance to cartesian coordinates</span>
<span class="c1">#</span>
<span class="c1">#   ellcurvature - Multiplication factors to convert latitude and longitude angles to meters.</span>
<span class="c1">#   ellnormal    - Unit normal vector (ECEF) at a given location perpendicular to the ellipsoid.</span>
<span class="c1">#   ellrotmatrix - Rotation matrix/matrices to transform coordinate differences.</span>
<span class="c1">#   covtransform - Transform and reformat (compact) co-variance matrices</span>

<div class="viewcode-block" id="xyz2neu">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.xyz2neu.html#pymgp.crstrans.xyz2neu">[docs]</a>
<span class="k">def</span> <span class="nf">xyz2neu</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;ref&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;plh&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">rotmatrix</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Cartesian XYZ coordinates to local coordinates (North,East,Up).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xyz : array_like with shape (...,3) </span>
<span class="sd">        Cartesian XYZ coordinates. The origin is either in the center of the Earth or at the</span>
<span class="sd">        position given by the second argument `ref`.</span>
<span class="sd">    ref : array_like with shape (...,3) or (...,2)</span>
<span class="sd">        Reference position(s) on the ellipsoid. The type of coordinates are specified by `mode`.</span>
<span class="sd">        `ref` can be a vector with a single coordinate triplet/doublet or have a similar shape</span>
<span class="sd">        to `xyz`. The North, East, Up coordinates for the(se) point(s) are (0, 0, 0). In case `ref`</span>
<span class="sd">        is a single coordinate triplet/doublet then the same reference points is used for all</span>
<span class="sd">        the points in `xyz`. </span>
<span class="sd">    origin : {&#39;ref&#39;, &#39;ecef&#39;}, default=&#39;ref&#39;</span>
<span class="sd">        Origin of the coordinates in `xyz`. If origin=&#39;ref&#39; then the XYZ coordinates in `xyz`</span>
<span class="sd">        are with respect to the point(s) given in `ref`. The other possibility is coordinates</span>
<span class="sd">        in the ECEF reference frame with the origin at the center of the Earth.</span>
<span class="sd">    mode : {&#39;plh&#39;, &#39;xyz&#39;,&#39;normal&#39;}, default = &#39;plh&#39;</span>
<span class="sd">        Coordinate type for `ref`. Possible values are:    </span>
<span class="sd">            </span>
<span class="sd">         - &#39;plh&#39; : `ref` contains the geographic latitude and longitude with the unit specified by </span>
<span class="sd">           `unit`. A third coordinate with the height is optional.</span>
<span class="sd">         - &#39;xyz&#39; : `ref` contains cartesian XYZ coordinates in the ECEF of a point (close) to the </span>
<span class="sd">           ellipsoid. The normal vector is computed for a point on the ellipsoid above or below `ref`.</span>
<span class="sd">         - &#39;normal&#39; : `ref` contains a normal vector with Cartesian coordinates. It does</span>
<span class="sd">           not necessarily have to be a unit vector (the function returns the unit vector). This</span>
<span class="sd">           options only works when the origin of the `xyz` coordinates is `ref` (origin=&#39;ref&#39;).</span>
<span class="sd">           </span>
<span class="sd">    unit : {&#39;rad&#39;, &#39;deg&#39;},  default = &#39;rad&#39;</span>
<span class="sd">        Units for latitude and longitude, only useful in case mode=&#39;plh&#39; option is used.</span>
<span class="sd">    rotmatrix : bool, default=False</span>
<span class="sd">        Output the rotation matrix(es) as an optional output argument. The rotation matrix </span>
<span class="sd">        can be used for instance to convert the covariance matrix (when available and needed).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    neu : ndarray with shape (...,3) similar to `xyz`</span>
<span class="sd">        Local North, East, Up coordinates `neu` with respect to the point(s) in `ref`.</span>
<span class="sd">    R : ndarray with shape (...,3,3), optional</span>
<span class="sd">        Rotation matrix(es), with ``neu = dxyz @ R``. In case `ref` is a vector `R` is a 3-by-3 matrix , </span>
<span class="sd">        in case `ref` is a multidimensional array, `R` has one more dimension than `ref` with</span>
<span class="sd">        shape (...,3,3). The rotation matrix can be used for instance to convert the covariance matrix </span>
<span class="sd">        (when available and needed). The rotation matrix is the &quot;transpose&quot; of the rotation matrix of </span>
<span class="sd">        `xyz2neu` (but the same as `ellrotmatrix`).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The rotation matrix differs from the Matlab version in the sense that it is the transpose.</span>
<span class="sd">    This is intentional because of differences between Python and Matlab array storage, broadcasting </span>
<span class="sd">    rules, and matrix multiplication. Possible methods are::</span>

<span class="sd">       neu = dxyz @ R</span>
<span class="sd">       neu = np.matmul(dxyz, R)</span>
<span class="sd">       neu = np.einsum(&#39;...j,...ji&#39;,dxyz,R)</span>
<span class="sd">       </span>
<span class="sd">    The third method using Einstein summation is the most general. The first two methods only </span>
<span class="sd">    work for dxyz.shape (:,3) or (3,), and with R.shape(3,3), but fail with higher dimensions. </span>
<span class="sd">    The rotation matrix also differs between the inverse functions `xyz2neu` and `neu2xyz` who return</span>
<span class="sd">    transposed versions to each other so that the above mathematics remain the same.          </span>
<span class="sd">    </span>
<span class="sd">    To convert covariance matrices we recommend to use the function covtransform.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    neu2xyz, covtransform, ellnormal, ellrotmatrix</span>
<span class="sd">          </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create some test data</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; ref = [ 52*np.pi/180, 4*np.pi/180 ]</span>
<span class="sd">    &gt;&gt;&gt; refxyz = plh2xyz([52, 4, 0],unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dxyz = [1, 1, 1]</span>
<span class="sd">    &gt;&gt;&gt; xyz = refxyz + np.array(dxyz)</span>

<span class="sd">    The following examples all have the same ouput</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; neu = xyz2neu(dxyz, ref)</span>
<span class="sd">    &gt;&gt;&gt; neu = xyz2neu(dxyz, [52, 4], unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; neu = xyz2neu(dxyz, refxyz, mode=&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; neu = xyz2neu(xyz , refxyz, mode=&#39;xyz&#39;, origin=&#39;ecef&#39;)</span>
<span class="sd">    &gt;&gt;&gt; neu = xyz2neu(xyz, [52, 4, 0], origin=&#39;ecef&#39;, unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(neu)</span>
<span class="sd">    [-0.22539858  0.92780758  1.44511888]</span>

<span class="sd">    You can use only latitude and longitude in `ref`, but not in ECEF mode where </span>
<span class="sd">    `ref` MUST have three coordinates</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; neu = xyz2neu(dxyz, [52, 4], unit=&#39;deg&#39;)  # ok</span>
<span class="sd">    &gt;&gt;&gt; neu = xyz2neu(xyz, [52 , 4], unit=&#39;deg&#39;, origin=&#39;ecef&#39;)  # fails</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    AssertionError: Reference coordinate vector ref must have three coordinates when used in combination with origin=&#39;ecef&#39;.</span>

<span class="sd">    Examples with multi dimensional coordinate input `xyz`. The second parameter `ref` can either</span>
<span class="sd">    be a row vector or have the same shape as the first input `xyz`. The number of dimensions is not</span>
<span class="sd">    restricted to two.</span>

<span class="sd">    &gt;&gt;&gt; dxyz = [[ 1, 1, 1],[ 2, 2, 2],[ 3, 0, 0],[ 0, 4, 1]] </span>
<span class="sd">    &gt;&gt;&gt; neu = xyz2neu(dxyz, ref)                    # ref is a single coordinate doublet</span>
<span class="sd">    &gt;&gt;&gt; print(neu)</span>
<span class="sd">    [[-0.22539858  0.92780758  1.44511888]</span>
<span class="sd">     [-0.45079715  1.85561515  2.89023776]</span>
<span class="sd">     [-2.3582736  -0.20926942  1.84248526]</span>
<span class="sd">     [ 0.39578607  3.9902562   0.95979625]]</span>
<span class="sd">    &gt;&gt;&gt; neu1 = xyz2neu(dxyz, [ref ,ref, ref, ref])   # matching shapes (ref can be different for each point)</span>
<span class="sd">    &gt;&gt;&gt; neu2 = xyz2neu(dxyz, [ refxyz ,refxyz, refxyz, refxyz], mode=&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print( np.max(np.abs(neu1-neu)) &lt; 1e-8, np.max(np.abs(neu2-neu)) &lt; 1e-8)</span>
<span class="sd">    True True</span>
<span class="sd">    </span>
<span class="sd">    Example with additional rotation matrix output</span>

<span class="sd">    &gt;&gt;&gt; neu, R = xyz2neu(dxyz, ref, rotmatrix=True)  # Rotation matrix output</span>
<span class="sd">    &gt;&gt;&gt; print(R)</span>
<span class="sd">    [[-0.7860912  -0.06975647  0.61416175]</span>
<span class="sd">     [-0.05496885  0.99756405  0.04294637]</span>
<span class="sd">     [ 0.61566148  0.          0.78801075]]</span>
<span class="sd">    &gt;&gt;&gt; print(np.all(neu - np.array(dxyz) @ R &lt; 1e-14))   </span>
<span class="sd">    True</span>
<span class="sd">    </span>
<span class="sd">    The following two examples do not give the same results because the up-direction </span>
<span class="sd">    is different (geodetic versus astronomic)</span>

<span class="sd">    &gt;&gt;&gt; xyz2neu([1, 1, 1], refxyz, mode=&#39;xyz&#39;)     # same result as neu = xyz2neu(dxyz,ref)</span>
<span class="sd">    array([-0.22539858,  0.92780758,  1.44511888])</span>
<span class="sd">    &gt;&gt;&gt; xyz2neu([1, 1, 1], refxyz, mode=&#39;normal&#39;)</span>
<span class="sd">    array([-0.2206844 ,  0.92780758,  1.44584629])</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span> 
        
    <span class="c1"># Force input arrays to ndarray and check the shapes</span>
    
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">,</span> <span class="s2">&quot;Cartesian vector xyz must have three coordinates (XYZ).&quot;</span> 
    <span class="k">assert</span> <span class="n">origin</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ref&#39;</span> <span class="p">,</span><span class="s1">&#39;ecef&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported origin </span><span class="si">{</span><span class="n">origin</span><span class="si">}</span><span class="s2">.&quot;</span>

    <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>  <span class="p">,</span> <span class="s2">&quot;Reference coordinate vector ref must have two or three coordinates.&quot;</span> 
    <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">t1</span><span class="o">=</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">t2</span><span class="o">=</span><span class="n">ref</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">t1</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">t2</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Reference coordinate vector must have dimension one or similar shape to xyz.&quot;</span>

    <span class="c1"># coordinates with respect to the reference point</span>
    
    <span class="k">if</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;ecef&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;plh&#39;</span><span class="p">:</span> 
            <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>  <span class="p">,</span> <span class="s2">&quot;Reference coordinate vector ref must have three coordinates when used in combination with origin=&#39;ecef&#39;.&quot;</span> 
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span> <span class="o">-</span> <span class="n">plh2xyz</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;xyz&#39;</span><span class="p">:</span> 
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span> <span class="o">-</span> <span class="n">ref</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Normal vector mode is not supported with origin=&#39;ecef&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># Compute normal vector at the reference position(s)</span>
    
    <span class="n">n</span> <span class="o">=</span> <span class="n">ellnormal</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
    
    <span class="c1"># Do the actual computation </span>

    <span class="c1"># neu = [ ( -n(:,1).*xyz(:,1) - n(:,2).*xyz(:,2) ) .* n(:,3) ./ cphi + cphi.*xyz(:,3)     ...</span>
    <span class="c1">#         ( -n(:,2).*xyz(:,1) + n(:,1).*xyz(:,2) ) ./  cphi                              ...</span>
    <span class="c1">#            n(:,1).*xyz(:,1) + n(:,2).*xyz(:,2) + n(:,3).*xyz(:,3) ]</span>
    
    <span class="n">cphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ip</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">neu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span>  <span class="p">(</span> <span class="n">ip</span> <span class="o">*</span> <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>  <span class="o">+</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="n">cphi</span> <span class="p">,</span>
                      <span class="p">(</span> <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span>  <span class="n">cphi</span> <span class="p">,</span>
                        <span class="n">ip</span>  <span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span> <span class="p">)</span>
      
    <span class="c1"># Optionally output the rotation matrix/matrices (see also ellrotmatrix)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">rotmatrix</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">neu</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[[</span> <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">cphi</span> <span class="p">,</span>  <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">cphi</span>        <span class="p">,</span>  <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span>  
                       <span class="p">[</span> <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">cphi</span> <span class="p">,</span>   <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">cphi</span>        <span class="p">,</span>  <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span>
                       <span class="p">[</span>                    <span class="n">cphi</span> <span class="p">,</span>   <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cphi</span><span class="p">)</span>  <span class="p">,</span>  <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">]</span> <span class="p">]</span> <span class="p">)</span>  
        <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">neu</span><span class="p">,</span> <span class="n">R</span></div>




<div class="viewcode-block" id="neu2xyz">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.neu2xyz.html#pymgp.crstrans.neu2xyz">[docs]</a>
<span class="k">def</span> <span class="nf">neu2xyz</span><span class="p">(</span><span class="n">neu</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;ref&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;plh&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">rotmatrix</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert local coordinates (North,East,Up) to Cartesian coordinates aligned to the ECEF frame.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    neu : array_like with shape (...,3) </span>
<span class="sd">        Local North, East, Up coordinates with respect to the point(s) in `ref`.</span>
<span class="sd">    ref : array_like with shape (...,3) or (...,2)</span>
<span class="sd">        Reference position(s) on the ellipsoid. The type of coordinates are specified by `mode`.</span>
<span class="sd">        &#39;ref&#39; can be a vector with a single coordinate triplet/doublet or have a similar shape</span>
<span class="sd">        to `neu`. The North, East, Up coordinates for the(se) point(s) are (0, 0, 0). In case `ref`</span>
<span class="sd">        is a single coordinate triplet/doublet then the same reference points is used for all</span>
<span class="sd">        the points in `neu`. </span>
<span class="sd">    origin : {&#39;ref&#39;, &#39;ecef&#39;}, default=&#39;ref&#39;</span>
<span class="sd">        Origin of the coordinates in the output XYZ coordinates. If origin=&#39;ref&#39; then the XYZ </span>
<span class="sd">        coordinates in the output are with respect to the point(s) given in `ref`. The other </span>
<span class="sd">        possibility is coordinates in the ECEF reference frame with the origin at the center </span>
<span class="sd">        of the Earth.</span>
<span class="sd">    mode : {&#39;plh&#39;, &#39;xyz&#39;,&#39;normal&#39;}, default = &#39;plh&#39;</span>
<span class="sd">        Coordinate type for `ref`. Possible values are: </span>
<span class="sd">            </span>
<span class="sd">         - &#39;plh&#39; : `ref` contains the geographic latitude and longitude with the unit </span>
<span class="sd">           specified by `unit`. A third coordinate with the height is optional.</span>
<span class="sd">         - &#39;xyz&#39; : `ref` contains cartesian XYZ coordinates in the ECEF of a point (close) </span>
<span class="sd">           to the ellipsoid. The normal vector is computed for a point on the ellipsoid </span>
<span class="sd">           above or below `ref`.</span>
<span class="sd">         - &#39;normal&#39; : `ref` contains a normal vector with Cartesian coordinates. It does </span>
<span class="sd">           not necessarily have to be a unit vector (the function returns the unit vector).</span>
<span class="sd">           </span>
<span class="sd">    unit : {&#39;rad&#39;, &#39;deg&#39;},  default = &#39;rad&#39;</span>
<span class="sd">        Units for latitude and longitude, only useful in case the &#39;plh&#39; options is used.</span>
<span class="sd">    rotmatrix : bool, default=False</span>
<span class="sd">        Output the rotation matrix(es) as an optional output argument. The rotation matrix </span>
<span class="sd">        can be used for instance to convert the covariance matrix (when available and needed).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xyz : ndarray with shape (...,3) similar to `neu`</span>
<span class="sd">        Cartesian XYZ coordinates. The origin is either in the center of the Earth or at the</span>
<span class="sd">        position given by `ref`.</span>
<span class="sd">    R : ndarray with shape (...,3,3), optional</span>
<span class="sd">        Rotation matrix(es), with ``dxyz = neu @ R``. In case `ref` is a vector `R` is a 3-by-3 matrix , </span>
<span class="sd">        in case `ref` is a multidimensional array, `R` has one more dimension than `ref` with</span>
<span class="sd">        shape (...,3,3). The rotation matrix can be used for instance to convert the covariance matrix </span>
<span class="sd">        (when available and needed). The rotation matrix is the &quot;transpose&quot; of the rotation matrix of </span>
<span class="sd">        `xyz2neu` and `ellrotmatrix`. </span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The rotation matrix differs from the Matlab version in the sense that it is the transpose.</span>
<span class="sd">    This is intentional because of differences between Python and Matlab array storage, broadcasting </span>
<span class="sd">    rules, and matrix multiplication. Possible methods are::</span>

<span class="sd">       dxyz = neu @ R</span>
<span class="sd">       dxyz = np.matmul(neu, R)</span>
<span class="sd">       dxyz = np.einsum(&#39;...j,...ji&#39;,neu,R)</span>
<span class="sd">       </span>
<span class="sd">    The third method using Einstein summation is the most general. The first two methods only </span>
<span class="sd">    work for dxyz.shape (:,3) or (3,), and with R.shape(3,3), but fail with higher dimensions. </span>
<span class="sd">    The rotation matrix also differs between the inverse functions `xyz2neu` and `neu2xyz` who return</span>
<span class="sd">    transposed versions to each other so that the above mathematics remain the same.          </span>
<span class="sd">    </span>
<span class="sd">    To convert covariance matrices we recommend to use the function covtransform.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    xyz2neu, covtransform, ellnormal, ellrotmatrix                     </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create some test data</span>

<span class="sd">    &gt;&gt;&gt; ref = [ 52*np.pi/180, 4*np.pi/180 ]</span>
<span class="sd">    &gt;&gt;&gt; refxyz = plh2xyz([52, 4, 0],unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; neu = [1, 1, 1]</span>
<span class="sd">    </span>
<span class="sd">    The following examples all have the same output as coordinate delta&#39;s</span>

<span class="sd">    &gt;&gt;&gt; dxyz = neu2xyz(neu, ref)</span>
<span class="sd">    &gt;&gt;&gt; dxyz = neu2xyz(neu, [52, 4], unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dxyz = neu2xyz(neu, refxyz, mode=&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(dxyz)</span>
<span class="sd">    [-0.24168592  0.98554157  1.40367223]</span>

<span class="sd">    The following examples refer to the same point, but as absolute coordinates</span>

<span class="sd">    &gt;&gt;&gt; xyz = neu2xyz(neu, refxyz, mode=&#39;xyz&#39;, origin=&#39;ecef&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xyz = neu2xyz(neu, [52, 4, 0], origin=&#39;ecef&#39;, unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(np.round(xyz,4))</span>
<span class="sd">    [3925374.8591  274489.952  5002804.7492]</span>
<span class="sd">    </span>
<span class="sd">    You can use only latitude and longitude in `ref`, but not in ECEF mode where </span>
<span class="sd">    `ref` MUST have three coordinates</span>

<span class="sd">    &gt;&gt;&gt; dxyz = neu2xyz(neu, [52, 4], unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xyz = neu2xyz(neu, [52 , 4], unit=&#39;deg&#39;, origin=&#39;ecef&#39;)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      ...</span>
<span class="sd">    AssertionError: Reference coordinate vector ref must have three coordinates when used in combination with origin=&#39;ecef&#39;.</span>

<span class="sd">    Examples with multi dimensional coordinate input `neu`. The second parameter `ref` can either</span>
<span class="sd">    be a row vector or have the same shape as the first input `neu`. The number of dimensions is not</span>
<span class="sd">    restricted to two.</span>

<span class="sd">    &gt;&gt;&gt; neu = [[ 1, 1, 1],[ 2, 2, 2],[ 3, 0, 0],[ 0, 4, 1]] </span>
<span class="sd">    &gt;&gt;&gt; dxyz = neu2xyz(neu, ref)                    # ref is a single coordinate doublet</span>
<span class="sd">    &gt;&gt;&gt; print(dxyz)</span>
<span class="sd">    [[-0.24168592  0.98554157  1.40367223]</span>
<span class="sd">     [-0.48337184  1.97108314  2.80734446]</span>
<span class="sd">     [-2.3582736  -0.16490655  1.84698443]</span>
<span class="sd">     [ 0.33513586  4.03320257  0.78801075]]</span>
<span class="sd">    &gt;&gt;&gt; dxyz1 = neu2xyz(neu, [ref ,ref, ref, ref])   # matching shapes (ref can be different for each point)</span>
<span class="sd">    &gt;&gt;&gt; dxyz2 = neu2xyz(neu, [ refxyz ,refxyz, refxyz, refxyz], mode=&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print( np.max(np.abs(dxyz1-dxyz)) &lt; 1e-8, np.max(np.abs(dxyz2-dxyz)) &lt; 1e-8)</span>
<span class="sd">    True True</span>

<span class="sd">    Example with additional rotation matrix output</span>

<span class="sd">    &gt;&gt;&gt; dxyz, R = neu2xyz(neu, ref, rotmatrix=True)  # Rotation matrix output</span>
<span class="sd">    &gt;&gt;&gt; print(R)</span>
<span class="sd">    [[-0.7860912  -0.05496885  0.61566148]</span>
<span class="sd">     [-0.06975647  0.99756405  0.        ]</span>
<span class="sd">     [ 0.61416175  0.04294637  0.78801075]]</span>
<span class="sd">    &gt;&gt;&gt; print(np.all(dxyz - np.array(neu) @ R &lt; 1e-14))  </span>
<span class="sd">    True</span>
<span class="sd">    </span>
<span class="sd">    The following two examples do not give the same results because the up-direction </span>
<span class="sd">    is different (geodetic versus astronomic)</span>

<span class="sd">    &gt;&gt;&gt; neu2xyz([1, 1, 1], refxyz, mode=&#39;xyz&#39;)     # same result as dxyz = neu2xyz(neu,ref)</span>
<span class="sd">    array([-0.24168592,  0.98554157,  1.40367223])</span>
<span class="sd">    &gt;&gt;&gt; neu2xyz([1, 1, 1], refxyz, mode=&#39;normal&#39;)</span>
<span class="sd">    array([-0.23711835,  0.98586097,  1.40422685])</span>
<span class="sd">        </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    
    <span class="c1"># Force input arrays to ndarray and check the shapes</span>
    
    <span class="n">neu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">neu</span><span class="p">)</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">neu</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">,</span> <span class="s2">&quot;Coordinate vector neu must have three coordinates (NEU).&quot;</span> 
    <span class="k">assert</span> <span class="n">origin</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ref&#39;</span> <span class="p">,</span><span class="s1">&#39;ecef&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported origin </span><span class="si">{</span><span class="n">origin</span><span class="si">}</span><span class="s2">.&quot;</span>

    <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>  <span class="p">,</span> <span class="s2">&quot;Reference coordinate vector ref must have two or three coordinates.&quot;</span> 
    <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">t1</span><span class="o">=</span><span class="n">neu</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">t2</span><span class="o">=</span><span class="n">ref</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">t1</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">t2</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Reference coordinate vector must have dimension one or similar shape to neu.&quot;</span>

    <span class="c1"># Compute normal vector at the reference position(s)</span>
    
    <span class="n">n</span> <span class="o">=</span> <span class="n">ellnormal</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
    
    <span class="c1"># Do the actual computation </span>
    
    <span class="c1"># xyz = [  -n(:,1).*n(:,3)./cphi.*neu(:,1)  - n(:,2)./cphi.*neu(:,2) + n(:,1).*neu(:,3)   ...</span>
    <span class="c1">#          -n(:,2).* n(:,3)./cphi.*neu(:,1) + n(:,1)./cphi.*neu(:,2) + n(:,2).*neu(:,3)   ...</span>
    <span class="c1">#           cphi.*neu(:,1)                                           + n(:,3).*neu(:,3)    ]</span>

    <span class="n">cphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span> 
        <span class="p">(</span> <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">neu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">neu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="n">cphi</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">neu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>   <span class="p">,</span>
        <span class="p">(</span> <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">neu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">neu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="n">cphi</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">neu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>   <span class="p">,</span>
                        <span class="n">cphi</span><span class="o">*</span><span class="n">neu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>                                <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">neu</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>   <span class="p">)</span> <span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="c1"># coordinates with respect to the reference point</span>
    
    <span class="k">if</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;ecef&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;plh&#39;</span><span class="p">:</span> 
            <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>  <span class="p">,</span> <span class="s2">&quot;Reference coordinate vector ref must have three coordinates when used in combination with origin=&#39;ecef&#39;.&quot;</span> 
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span> <span class="o">+</span> <span class="n">plh2xyz</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;xyz&#39;</span><span class="p">:</span> 
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span> <span class="o">+</span> <span class="n">ref</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Normal vector mode is not supported with origin=&#39;ecef&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># Optionally output the rotation matrix/matrices (see also ellrotmatrix)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">rotmatrix</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xyz</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[[</span> <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">cphi</span> <span class="p">,</span>  <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">cphi</span>        <span class="p">,</span>  <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span>  
                       <span class="p">[</span> <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">cphi</span> <span class="p">,</span>   <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">cphi</span>        <span class="p">,</span>  <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span>
                       <span class="p">[</span>                    <span class="n">cphi</span> <span class="p">,</span>   <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cphi</span><span class="p">)</span>  <span class="p">,</span>  <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">]</span> <span class="p">]</span> <span class="p">)</span>  
        <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>    <span class="c1"># return the transpose</span>
        
        <span class="k">return</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">R</span></div>



<div class="viewcode-block" id="xyz2zas">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.xyz2zas.html#pymgp.crstrans.xyz2zas">[docs]</a>
<span class="k">def</span> <span class="nf">xyz2zas</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;ref&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;plh&#39;</span><span class="p">,</span> <span class="n">refunit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">zasunit</span><span class="o">=</span><span class="s1">&#39;rad/m&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cartesian XYZ coordinates to zenith angle, azimuth and distance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xyz : array_like with shape (...,3) </span>
<span class="sd">        Cartesian XYZ coordinates. The origin is either in the center of the Earth or at the</span>
<span class="sd">        position given by `ref`.</span>
<span class="sd">    ref : array_like shape (...,3) or (...,2)</span>
<span class="sd">        Reference position(s) on the ellipsoid. The type of coordinates are specified by `mode`.</span>
<span class="sd">        `ref` can be a vector with a single coordinate triplet/doublet or have a similar shape</span>
<span class="sd">        to `xyz`. The North, East, Up coordinates for the(se) point(s) are (0, 0, 0). In case `ref`</span>
<span class="sd">        is a single coordinate triplet/doublet then the same reference points is used for all</span>
<span class="sd">        the points in `xyz`. </span>
<span class="sd">    origin : {&#39;ref&#39;, &#39;ecef&#39;}, default=&#39;ref&#39;</span>
<span class="sd">        Origin of the coordinates in `xyz`. If origin=&#39;ref&#39; then the XYZ coordinates in `xyz`</span>
<span class="sd">        are with respect to the point(s) given in `ref`. The other possibility is coordinates</span>
<span class="sd">        in the ECEF reference frame with the origin at the center of the Earth.</span>
<span class="sd">    mode : {&#39;plh&#39;, &#39;xyz&#39;,&#39;normal&#39;}, default = &#39;plh&#39;</span>
<span class="sd">        Coordinate type for `ref`. Possible values are:</span>
<span class="sd">            </span>
<span class="sd">         - &#39;plh&#39; : `ref` contains the geographic latitude and longitude with the unit </span>
<span class="sd">           specified by `unit`. A third coordinate with the height is optional.</span>
<span class="sd">         - &#39;xyz&#39; : `ref` contains cartesian XYZ coordinates in the ECEF of a point (close) </span>
<span class="sd">           to the ellipsoid. The normal vector is computed for a point on the ellipsoid </span>
<span class="sd">           above or below `ref`.</span>
<span class="sd">         - &#39;normal&#39; : `ref` contains a normal vector with Cartesian coordinates. It does </span>
<span class="sd">           not necessarily have to be a unit vector (the function returns the unit vector).</span>
<span class="sd">           </span>
<span class="sd">    refunit : {&#39;rad&#39;, &#39;deg&#39;},  default = &#39;rad&#39;</span>
<span class="sd">        Units for latitude and longitude, only useful in case the &#39;plh&#39; options is used.</span>
<span class="sd">    zasunit : {&#39;rad/m&#39;, &#39;deg/m&#39;},  default = &#39;rad/m&#39;</span>
<span class="sd">        Units for zenith angle and azimuth.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    zas : ndarray with shape similar to `xyz`.</span>
<span class="sd">        Zenith angle (z), azimuth angle (a) and distance (s) from `ref` to `xyz`.</span>
<span class="sd">           </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Define a test case</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; ref = [52*np.pi/180, 4*np.pi/180 ]</span>
<span class="sd">    &gt;&gt;&gt; refxyz = plh2xyz([52, 4, 0],unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dxyz = [1, 1, 1]</span>
<span class="sd">    &gt;&gt;&gt; xyz = refxyz + np.array(dxyz)</span>

<span class="sd">    The following examples have the same result</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; zas = xyz2zas(dxyz, ref)</span>
<span class="sd">    &gt;&gt;&gt; zas = xyz2zas(dxyz, [52, 4], refunit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; zas = xyz2zas(dxyz, refxyz, mode=&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; zas = xyz2zas(xyz , refxyz, mode=&#39;xyz&#39;, origin=&#39;ecef&#39;)</span>
<span class="sd">    &gt;&gt;&gt; zas = xyz2zas(xyz, [52, 4, 0], origin=&#39;ecef&#39;, refunit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(zas)</span>
<span class="sd">    [0.58386231 1.80911628 1.73205081]</span>
<span class="sd">    </span>
<span class="sd">    Check that the inverse function returns the original</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; zas2xyz(zas,ref)</span>
<span class="sd">    array([1., 1., 1.])</span>
<span class="sd">    </span>
<span class="sd">    The following examples also have all the same result</span>

<span class="sd">    &gt;&gt;&gt; dxyz = [[ 1, 1, 1],[ 2, 2, 2],[ 3, 0, 0],[ 0, 4, 1]] </span>
<span class="sd">    &gt;&gt;&gt; zas = xyz2zas(dxyz, ref)                    # ref is a single coordinate doublet</span>
<span class="sd">    &gt;&gt;&gt; zas = xyz2zas(dxyz, refxyz, mode=&#39;xyz&#39;)    </span>
<span class="sd">    &gt;&gt;&gt; zas = xyz2zas(dxyz, [ref ,ref, ref, ref])   # matching shapes (ref can be different for each point)</span>
<span class="sd">    &gt;&gt;&gt; zas = xyz2zas(dxyz, [ refxyz ,refxyz, refxyz, refxyz], mode=&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(zas)</span>
<span class="sd">    [[ 0.58386231  1.80911628  1.73205081]</span>
<span class="sd">     [ 0.58386231  1.80911628  3.46410162]</span>
<span class="sd">     [ 0.90947297 -3.05308608  3.        ]</span>
<span class="sd">     [ 1.33585617  1.47193157  4.12310563]]</span>
<span class="sd">    </span>
<span class="sd">    The following two examples do not give the same results because the up-direction </span>
<span class="sd">    is different (geodetic versus astronomic)</span>

<span class="sd">    &gt;&gt;&gt; dxyz = [1, 1, 1]</span>
<span class="sd">    &gt;&gt;&gt; xyz2zas(dxyz, refxyz, mode=&#39;xyz&#39;)     # same result as z, a, s = xyz2zas(dxyz,ref)</span>
<span class="sd">    array([0.58386231, 1.80911628, 1.73205081])</span>
<span class="sd">    &gt;&gt;&gt; xyz2zas(dxyz, refxyz, mode=&#39;normal&#39;)</span>
<span class="sd">    array([0.58310003, 1.80431289, 1.73205081])</span>
<span class="sd">       </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    
    <span class="c1"># Force input arrays to ndarray and check the shapes</span>
    
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
    
    <span class="k">assert</span> <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">,</span> <span class="s2">&quot;Cartesian vector xyz must have three coordinates (XYZ).&quot;</span> 
    <span class="k">assert</span> <span class="n">origin</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ref&#39;</span> <span class="p">,</span><span class="s1">&#39;ecef&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported origin </span><span class="si">{</span><span class="n">origin</span><span class="si">}</span><span class="s2">.&quot;</span>

    <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>  <span class="p">,</span> <span class="s2">&quot;Reference coordinate vector ref must have two or three coordinates.&quot;</span> 
    <span class="k">if</span> <span class="n">ref</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">t1</span><span class="o">=</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">t2</span><span class="o">=</span><span class="n">ref</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">assert</span> <span class="n">t1</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">t2</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Reference coordinate vector must have dimension one or similar shape to xyz.&quot;</span>

    <span class="c1"># coordinates with respect to the reference point</span>
    
    <span class="k">if</span> <span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;ecef&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;plh&#39;</span><span class="p">:</span> 
            <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>  <span class="p">,</span> <span class="s2">&quot;Reference coordinate vector ref must have three coordinates when used in combination with origin=&#39;ecef&#39;.&quot;</span> 
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span> <span class="o">-</span> <span class="n">plh2xyz</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">refunit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;xyz&#39;</span><span class="p">:</span> 
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span> <span class="o">-</span> <span class="n">ref</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Normal vector mode is not supported with origin=&#39;ecef&#39;.&quot;</span><span class="p">)</span>

    <span class="c1"># Compute normal vector at the reference position(s)</span>
    
    <span class="n">n</span> <span class="o">=</span> <span class="n">ellnormal</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">refunit</span><span class="p">)</span>
   
    <span class="c1"># Do the actual computation </span>

    <span class="c1"># neu = [ ( -n(:,1).*xyz(:,1) - n(:,2).*xyz(:,2) ) .* n(:,3) ./ cphi + cphi.*xyz(:,3)     ...</span>
    <span class="c1">#         ( -n(:,2).*xyz(:,1) + n(:,1).*xyz(:,2) ) ./  cphi                              ...</span>
    <span class="c1">#            n(:,1).*xyz(:,1) + n(:,2).*xyz(:,2) + n(:,3).*xyz(:,3) ]</span>
    <span class="c1">#</span>
    <span class="c1"># cphi= sqrt(1-n(:,3).^2);</span>
    <span class="c1"># ip=n(:,1).*xyz(:,1) + n(:,2).*xyz(:,2) + n(:,3).*xyz(:,3);</span>
    <span class="c1">#</span>
    <span class="c1"># neu = [ (  ip .* -n(:,3)  + xyz(:,3) ) ./ cphi               ...</span>
    <span class="c1">#         ( -n(:,2).*xyz(:,1) + n(:,1).*xyz(:,2) ) ./  cphi    ...</span>
    <span class="c1">#            ip                                                  ];</span>
    <span class="c1">#</span>
    <span class="c1"># s = sqrt( xyz(:,1).*xyz(:,1) + xyz(:,2).*xyz(:,2) + xyz(:,3).*xyz(:,3) );</span>
    <span class="c1"># z = acos(neu(:,3)./s);</span>
    <span class="c1"># a = atan2(neu(:,2),neu(:,1));</span>
    
    <span class="n">ip</span> <span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span>
    <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span> <span class="n">ip</span> <span class="o">/</span> <span class="n">s</span> <span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span>  <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span>   <span class="n">ip</span> <span class="o">*</span> <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>  <span class="o">+</span> <span class="n">xyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span>

    <span class="k">if</span> <span class="n">zasunit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;deg&#39;</span><span class="p">,</span> <span class="s1">&#39;deg/m&#39;</span><span class="p">]:</span>
        <span class="n">r2d</span> <span class="o">=</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r2d</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="n">zas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span> <span class="n">r2d</span><span class="o">*</span><span class="n">z</span><span class="p">,</span> <span class="n">r2d</span><span class="o">*</span><span class="n">a</span> <span class="p">,</span> <span class="n">s</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span> <span class="p">)</span>
      
    <span class="k">return</span> <span class="n">zas</span></div>



<div class="viewcode-block" id="zas2xyz">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.zas2xyz.html#pymgp.crstrans.zas2xyz">[docs]</a>
<span class="k">def</span> <span class="nf">zas2xyz</span><span class="p">(</span><span class="n">zas</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="s1">&#39;ref&#39;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;plh&#39;</span><span class="p">,</span> <span class="n">refunit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">zasunit</span><span class="o">=</span><span class="s1">&#39;rad/m&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Zenith angle, azimuth and distance to cartesian XYZ coordinates.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    zas : array_like with shape (...,3) </span>
<span class="sd">        Zenith angle, azimuth angle and distance from `ref` to `xyz`.</span>
<span class="sd">    ref : array_like with shape (...,3) or (...,2)</span>
<span class="sd">        Reference position(s) on the ellipsoid. The type of coordinates are specified by `mode`.</span>
<span class="sd">        `ref` can be a vector with a single coordinate triplet/doublet or have a similar shape</span>
<span class="sd">        to `neu`. The North, East, Up coordinates for the(se) point(s) are (0, 0, 0). In case `ref`</span>
<span class="sd">        is a single coordinate triplet/doublet then the same reference points is used for all</span>
<span class="sd">        the points in `neu`. </span>
<span class="sd">    origin : {&#39;ref&#39;, &#39;ecef&#39;}, default=&#39;ref&#39;</span>
<span class="sd">        Origin of the coordinates in the output XYZ coordinates. If origin=&#39;ref&#39; then the XYZ </span>
<span class="sd">        coordinates in the output are with respect to the point(s) given in `ref`. The other </span>
<span class="sd">        possibility is coordinates in the ECEF reference frame with the origin at the center </span>
<span class="sd">        of the Earth.</span>
<span class="sd">    mode : {&#39;plh&#39;, &#39;xyz&#39;,&#39;normal&#39;}, default = &#39;plh&#39;</span>
<span class="sd">        Coordinate type for `ref`. Possible values are:</span>
<span class="sd">            </span>
<span class="sd">         - &#39;plh&#39; : `ref` contains the geographic latitude and longitude with the unit </span>
<span class="sd">           specified by `unit`. A third coordinate with the height is optional.</span>
<span class="sd">         - &#39;xyz&#39; : `ref` contains cartesian XYZ coordinates in the ECEF of a point (close) </span>
<span class="sd">           to the ellipsoid. The normal vector is computed for a point on the ellipsoid </span>
<span class="sd">           above or below `ref`.</span>
<span class="sd">         - &#39;normal&#39; : `ref` contains a normal vector with Cartesian coordinates. It does </span>
<span class="sd">           not necessaraly have to be a unit vector (the function returns the unit vector).</span>
<span class="sd">           </span>
<span class="sd">    refunit : {&#39;rad&#39;, &#39;deg&#39;},  default = &#39;rad&#39;</span>
<span class="sd">        Units for latitude and longitude, only useful in case the &#39;plh&#39; options is used.</span>
<span class="sd">    zasunit : {&#39;rad/m&#39;, &#39;deg/m&#39;},  default = &#39;rad/m&#39;</span>
<span class="sd">        Units for latitude and longitude, only useful in case the &#39;plh&#39; options is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xyz : ndarray with shape (...,3) </span>
<span class="sd">        Cartesian XYZ coordinates. The origin is either in the center of the Earth or at the</span>
<span class="sd">        position given by `ref`.</span>
<span class="sd">           </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Define a test case</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; ref = [52*np.pi/180, 4*np.pi/180, 0 ]</span>
<span class="sd">    &gt;&gt;&gt; refxyz = plh2xyz([52, 4, 0],unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; zas = [0.1, np.pi/2, 1000]</span>

<span class="sd">    The following examples have the same result</span>

<span class="sd">    &gt;&gt;&gt; dxyz = zas2xyz(zas, ref)</span>
<span class="sd">    &gt;&gt;&gt; dxyz = zas2xyz(zas, [52, 4, 0], refunit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; dxyz = zas2xyz(zas, refxyz, mode=&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(dxyz)</span>
<span class="sd">    [604.12947719 142.32204802 784.07398212]</span>

<span class="sd">    Same, but with `ref` coordinates added</span>

<span class="sd">    &gt;&gt;&gt; xyz = zas2xyz(zas, refxyz, origin=&#39;ecef&#39;, mode=&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(np.round(xyz,4))</span>
<span class="sd">    [3925979.2303  274631.2885 5003587.4194]</span>

<span class="sd">    The following two examples do not give the same results because the up-direction </span>
<span class="sd">    is different (geodetic versus astronomic)</span>

<span class="sd">    &gt;&gt;&gt; zas2xyz(zas, refxyz, mode=&#39;xyz&#39;)   # same result as dxyz=zas2xyz(zas,ref)</span>
<span class="sd">    array([604.12947719, 142.32204802, 784.07398212])</span>
<span class="sd">    &gt;&gt;&gt; zas2xyz(zas, refxyz, mode=&#39;normal&#39;)</span>
<span class="sd">    array([606.67710196, 142.50019529, 782.07198409])</span>

<span class="sd">    Multi dimensional examples with all the same result</span>

<span class="sd">    &gt;&gt;&gt; zas = xyz2zas([[ 1, 1, 1],[ 2, 2, 2],[ 3, 0, 0],[ 0, 4, 1]],ref)</span>
<span class="sd">    &gt;&gt;&gt; dxyz = zas2xyz(zas, ref)                    # ref is a single coordinate doublet</span>
<span class="sd">    &gt;&gt;&gt; dxyz = zas2xyz(zas, refxyz, mode=&#39;xyz&#39;)    </span>
<span class="sd">    &gt;&gt;&gt; dxyz = zas2xyz(zas, [ref ,ref, ref, ref])   # matching shapes (ref can be different for each point)</span>
<span class="sd">    &gt;&gt;&gt; print(np.round(dxyz,14))</span>
<span class="sd">    [[1. 1. 1.]</span>
<span class="sd">     [2. 2. 2.]</span>
<span class="sd">     [3. 0. 0.]</span>
<span class="sd">     [0. 4. 1.]]</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    
    <span class="c1"># Force input array zas to ndarray, convert to neu, call neu2xyz to do the work</span>
    
    <span class="n">zas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">zas</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">zasunit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;deg&#39;</span><span class="p">,</span> <span class="s1">&#39;deg/m&#39;</span><span class="p">]:</span>
        <span class="n">d2r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d2r</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="n">neu</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span> <span class="n">zas</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">d2r</span><span class="o">*</span><span class="n">zas</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">d2r</span><span class="o">*</span><span class="n">zas</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="p">,</span>
                    <span class="n">zas</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">d2r</span><span class="o">*</span><span class="n">zas</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">d2r</span><span class="o">*</span><span class="n">zas</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="p">,</span>
                    <span class="n">zas</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">d2r</span><span class="o">*</span><span class="n">zas</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="p">)</span>       <span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">xyz</span> <span class="o">=</span> <span class="n">neu2xyz</span><span class="p">(</span><span class="n">neu</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">refunit</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">xyz</span></div>



<div class="viewcode-block" id="ellcurvature">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.ellcurvature.html#pymgp.crstrans.ellcurvature">[docs]</a>
<span class="k">def</span> <span class="nf">ellcurvature</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">=</span><span class="s1">&#39;current&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Multiplication factors to convert latitude and longitude angles to meters.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    lat : array_like or float</span>
<span class="sd">        Latitude in radians or degrees.  </span>
<span class="sd">    height : array_like or float</span>
<span class="sd">        Height in meters.</span>
<span class="sd">    unit : {&#39;rad&#39;, &#39;deg&#39;},  default = &#39;rad&#39;</span>
<span class="sd">        Unit of latitude (input) and for multiplication factors (output).</span>
<span class="sd">    ellipsoid : str or list of floats, default = &#39;current&#39;</span>
<span class="sd">        Text string with the name of the ellipse or a list ``[a, 1/f]`` with the semi-major </span>
<span class="sd">        axis `a` and inverse flattening `1/f`. The current ellipsoid can be set by</span>
<span class="sd">        `setell`. Default for the current ellips is &#39;WGS-84&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    flat, flon : float</span>
<span class="sd">        Conversion factors for latitude and longitude in `unit`.</span>
<span class="sd">                       </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; flat, flon = ellcurvature(52, 0, unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(flat, flon)</span>
<span class="sd">    111267.44260909088 68677.7753788433</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; print(f&#39;In Delft one arcsec is {flat/3600:.3f} m in latitude and {flon/3600 :.3f} m in longitude.&#39;)</span>
<span class="sd">    In Delft one arcsec is 30.908 m in latitude and 19.077 m in longitude.</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span> 

    <span class="k">assert</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;deg&#39;</span> <span class="p">,</span><span class="s1">&#39;rad&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported units </span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">.&quot;</span>

    <span class="c1"># semi-major axis a, flattening f and eccentricy squared e2  </span>
    
    <span class="n">a</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">GM</span> <span class="o">=</span> <span class="n">inqell</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">)</span>
    <span class="n">e2</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="o">**</span><span class="mi">2</span>         <span class="c1"># eccentricity squared</span>
          
    <span class="c1"># the reference position is somewhere in the middle (mean)</span>

    <span class="k">if</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;deg&#39;</span><span class="p">,</span> <span class="s1">&#39;deg/m&#39;</span><span class="p">]:</span>
        <span class="n">d2r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d2r</span> <span class="o">=</span> <span class="mf">1.</span>

    <span class="n">latref</span> <span class="o">=</span> <span class="n">d2r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">lat</span><span class="p">)</span>    
    <span class="n">heightref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">height</span><span class="p">)</span>

    <span class="c1"># curvatures (radius) for the chosen ellipsoid</span>
    
    <span class="n">N_curvature</span> <span class="o">=</span> <span class="n">a</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">e2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">latref</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>       
    <span class="n">M_curvature</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">e2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">e2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">latref</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="mi">3</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> 
    
    <span class="n">flat</span> <span class="o">=</span> <span class="n">d2r</span> <span class="o">*</span> <span class="p">(</span> <span class="n">M_curvature</span> <span class="o">+</span> <span class="n">heightref</span> <span class="p">)</span> 
    <span class="n">flon</span> <span class="o">=</span> <span class="n">d2r</span> <span class="o">*</span> <span class="p">(</span> <span class="n">N_curvature</span> <span class="o">+</span> <span class="n">heightref</span> <span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">latref</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">flat</span><span class="p">,</span> <span class="n">flon</span></div>



<div class="viewcode-block" id="ellnormal">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.ellnormal.html#pymgp.crstrans.ellnormal">[docs]</a>
<span class="k">def</span> <span class="nf">ellnormal</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;plh&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute unit normal vector (ECEF) perpendicular to the ellipsoid at a given location.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ref : array_like with shape (...,3) or (...,2)</span>
<span class="sd">        Reference position(s) on the ellipsoid. The type of coordinates are specified by `mode`.</span>
<span class="sd">        `ref` can be a vector with more than one coordinate triplet/doublet.  </span>
<span class="sd">    mode : {&#39;plh&#39;, &#39;xyz&#39;,&#39;normalize&#39;}, default = &#39;plh&#39;</span>
<span class="sd">        Coordinate type for `ref`. Possible values are:  </span>
<span class="sd">            </span>
<span class="sd">        - &#39;plh&#39; : `ref` contains the geographic latitude and longitude with the unit </span>
<span class="sd">          specified by `unit`. A third coordinate with the height is optional, but not used.</span>
<span class="sd">        - &#39;xyz&#39; : `ref` contains cartesian XYZ coordinates in the ECEF of a point (close) </span>
<span class="sd">          to the ellipsoid. The normal vector is computed for a point on the ellipsoid </span>
<span class="sd">          above or below `ref`.</span>
<span class="sd">        - &#39;normal&#39; : `ref` contains a vector with Cartesian coordinates. The function </span>
<span class="sd">          returns the normalized unit vector.</span>
<span class="sd">           </span>
<span class="sd">    unit : {&#39;rad&#39;, &#39;deg&#39;},  default = &#39;rad&#39;</span>
<span class="sd">        Units for latitude and longitude, only useful in case the mode=&#39;plh&#39; option is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    n : ndarray with shape (...,3)</span>
<span class="sd">        Unit normal vector(s) in Cartesian XYZ coordinates.</span>
<span class="sd">        </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ellrotmatrix, xyz2neu, neu2xyz</span>
<span class="sd">                </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; n = ellnormal([52*np.pi/180, 4*np.pi/180])</span>
<span class="sd">    &gt;&gt;&gt; print(n)</span>
<span class="sd">    [0.61416175 0.04294637 0.78801075]</span>
<span class="sd">    &gt;&gt;&gt; n = ellnormal([52, 4], unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(n)</span>
<span class="sd">    [0.61416175 0.04294637 0.78801075]</span>

<span class="sd">    &gt;&gt;&gt; n = ellnormal([[50, 0], [52, 4]] , unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(n)</span>
<span class="sd">    [[0.64278761 0.         0.76604444]</span>
<span class="sd">     [0.61416175 0.04294637 0.78801075]]</span>
<span class="sd">    &gt;&gt;&gt; n = ellnormal([[50, 0, 0], [52, 4, 2]] , unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(n)</span>
<span class="sd">    [[0.64278761 0.         0.76604444]</span>
<span class="sd">     [0.61416175 0.04294637 0.78801075]]</span>

<span class="sd">    &gt;&gt;&gt; xyz = plh2xyz([[50, 0, 0], [52, 4, 2]] , unit=&#39;deg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; n  = ellnormal(xyz, mode=&#39;xyz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(n)</span>
<span class="sd">    [[0.64278761 0.         0.76604444]</span>
<span class="sd">     [0.61416175 0.04294637 0.78801075]]</span>

<span class="sd">    The next example does not give the same result as above because the normal </span>
<span class="sd">    direction is different </span>

<span class="sd">    &gt;&gt;&gt; n = ellnormal(xyz, mode=&#39;normal&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(n)</span>
<span class="sd">    [[0.64531918 0.         0.76391306]</span>
<span class="sd">     [0.61672217 0.04312542 0.7859987 ]]</span>

<span class="sd">    &quot;&quot;&quot;</span> 

    <span class="k">assert</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;plh&#39;</span> <span class="p">,</span><span class="s1">&#39;xyz&#39;</span><span class="p">,</span> <span class="s1">&#39;normal&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported mode </span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">.&quot;</span>
    
    <span class="n">ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;plh&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span>  <span class="p">,</span> <span class="s2">&quot;Geographic coordinate vector ref must contain at least latitude and longitude (height is optional).&quot;</span> 
        <span class="k">assert</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rad&#39;</span> <span class="p">,</span><span class="s1">&#39;deg&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported unit </span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;deg&#39;</span><span class="p">:</span>
            <span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span><span class="p">[</span><span class="o">...</span><span class="p">,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span> 
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ref</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ref</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">,</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ref</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ref</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">,</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ref</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;xyz&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">,</span> <span class="s2">&quot;Cartesian coordinate vector ref must have three coordinates (XYZ).&quot;</span> 
        <span class="n">ref</span> <span class="o">=</span> <span class="n">xyz2plh</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ref</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ref</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">,</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ref</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ref</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span> <span class="p">,</span>
                       <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ref</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
        <span class="c1"># ref contains normal vector -&gt; normalize to unit vector</span>
        <span class="k">assert</span> <span class="n">ref</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">,</span> <span class="s2">&quot;Normal vector ref must have three coordinates (XYZ).&quot;</span> 
        <span class="n">n</span> <span class="o">=</span> <span class="n">ref</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ref</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">n</span></div>



<div class="viewcode-block" id="ellrotmatrix">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.ellrotmatrix.html#pymgp.crstrans.ellrotmatrix">[docs]</a>
<span class="k">def</span> <span class="nf">ellrotmatrix</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;plh&#39;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rotation matrix for ECEF to topocentric coordinates.</span>
<span class="sd">    </span>
<span class="sd">    Compute rotation matrix/matrices to transform coordinate differences alligned to an </span>
<span class="sd">    ECEF frame into a topocentric reference frame with North, East, Up coordinates. </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ref : array_like with shape (...,3) or (...,2)</span>
<span class="sd">        Reference position(s) on the ellipsoid. The type of coordinates are specified by `mode`.</span>
<span class="sd">        `ref` can be a vector with more than one coordinate triplet/doublet.  </span>
<span class="sd">    mode : {&#39;plh&#39;, &#39;xyz&#39;,&#39;normal&#39;}, default = &#39;plh&#39;</span>
<span class="sd">        Coordinate type for `ref`. Possible values are:</span>
<span class="sd">            </span>
<span class="sd">         - &#39;plh&#39; : `ref` contains the geographic latitude and longitude with the unit </span>
<span class="sd">           specified by `unit`. A third coordinate with the height is optional, but not used.</span>
<span class="sd">         - &#39;xyz&#39; : `ref` contains cartesian XYZ coordinates in the ECEF of a point (close) </span>
<span class="sd">           to the ellipsoid. The normal vector is computed for a point on the ellipsoid </span>
<span class="sd">           above or below `ref`.</span>
<span class="sd">         - &#39;normal&#39; : `ref` contains a normal vector with Cartesian coordinates. It does </span>
<span class="sd">           not necessaraly have to be a unit vector.</span>
<span class="sd">           </span>
<span class="sd">    unit : {&#39;rad&#39;, &#39;deg&#39;},  default = &#39;rad&#39;</span>
<span class="sd">        Units for latitude and longitude, only useful in case the mode=&#39;plh&#39; option is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    R : ndarray with shape (...,3,3)</span>
<span class="sd">        Rotation matrix(es) to transform `dxyz` into `neu`, with ``neu = dxyz @ R``. In case `ref` </span>
<span class="sd">        is a vector, `R` becomes a 3-by-3 matrix , in case `ref` is a multidimensional array, `R` </span>
<span class="sd">        will have one more dimension than `ref` with shape (...,3,3). </span>
<span class="sd">    </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The parameters are passed to `ellnormal` to compute the unit normal vector from which</span>
<span class="sd">    the rotation matrix is computed. </span>

<span class="sd">    The rotation is defined as::</span>
<span class="sd">    </span>
<span class="sd">        neu = dxyz @  R     or    neu = R.T @ dxyz.T   , and    Qneu =  R.T @ Qxyz @ R     </span>
<span class="sd">        dxyz =  neu @ R.T   or    dxyz = R @ neu.T     , and    Qxyz =  R @ Qneu @ R.T</span>
<span class="sd">        </span>
<span class="sd">    For a rotation matrix with more than two dimensions, Einstein multiplication should be used::</span>

<span class="sd">        neu = np.einsum(&#39;...ji,...j&#39;,R,dxyz)   or  neu = np.einsum(&#39;...j,...ji&#39;,dxyz,R)</span>
<span class="sd">        dxyz = np.einsum(&#39;...ij,...j&#39;,R,neu)   or  dxyz = np.einsum(&#39;...ij,...j&#39;,R,neu)</span>
<span class="sd">    </span>
<span class="sd">    Einstein multiplication also works for two dimensions. For coordinate transformations the </span>
<span class="sd">    results are identical to the more efficient and powerful functions `xyz2neu` and `neu2xyz`.</span>
<span class="sd">    </span>
<span class="sd">    The rotation matrix is used by `covtransform` to convert covariance matrices.</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ellnormal, covtransform</span>
<span class="sd">                           </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; R = ellrotmatrix([52, 4], unit=&#39;deg&#39;)  </span>
<span class="sd">    &gt;&gt;&gt; print(R)</span>
<span class="sd">    [[-0.7860912  -0.06975647  0.61416175]</span>
<span class="sd">     [-0.05496885  0.99756405  0.04294637]</span>
<span class="sd">     [ 0.61566148  0.          0.78801075]]</span>
<span class="sd">     </span>
<span class="sd">    &gt;&gt;&gt; dxyz=np.array([[1, 1, 1],[2, 1, 3]])</span>
<span class="sd">    &gt;&gt;&gt; neu = dxyz @ R</span>
<span class="sd">    &gt;&gt;&gt; print(neu)</span>
<span class="sd">    [[-0.22539858  0.92780758  1.44511888]</span>
<span class="sd">     [ 0.21983318  0.8580511   3.63530214]]</span>
<span class="sd">    &gt;&gt;&gt; np.einsum(&#39;...ji,...j&#39;,R,dxyz)</span>
<span class="sd">    array([[-0.22539858,  0.92780758,  1.44511888],</span>
<span class="sd">           [ 0.21983318,  0.8580511 ,  3.63530214]])</span>
<span class="sd">    &gt;&gt;&gt; np.einsum(&#39;...ij,...j&#39;,R,neu)</span>
<span class="sd">    array([[1., 1., 1.],</span>
<span class="sd">           [2., 1., 3.]])</span>

<span class="sd">    &gt;&gt;&gt; R = ellrotmatrix([[52, 4],[52, -34]], unit=&#39;deg&#39;)  </span>
<span class="sd">    &gt;&gt;&gt; print(R.shape)</span>
<span class="sd">    (2, 3, 3)</span>
<span class="sd">    &gt;&gt;&gt; dxyz=np.array([[1, 1, 1],[2, 1, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.einsum(&#39;...ji,...j&#39;,R,dxyz)</span>
<span class="sd">    array([[-0.22539858,  0.92780758,  1.44511888],</span>
<span class="sd">           [ 0.9810534 ,  1.94742338,  3.04057172]])</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span> 

    <span class="c1"># normal vector</span>
        
    <span class="n">n</span> <span class="o">=</span> <span class="n">ellnormal</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="n">unit</span><span class="p">)</span>
        
    <span class="n">cphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
      
    <span class="c1"># Rotation matrix</span>
    
    <span class="c1">#    | n |   | -n(k,1)*n(k,3)/cphi  -n(k,2)*n(k,3)/cphi  cphi   |  | x |         | x |</span>
    <span class="c1">#    | e | = | -n(k,2)/cphi          n(k,1)/cphi         0      |  | y | = R.T @ | y |</span>
    <span class="c1">#    | u |   |  n(k,1)               n(k,2)              n(k,3) |  | z |         | z |</span>
    
    <span class="c1">#    [n, e, u] = [x, y, z]  | -n(k,1)*n(k,3)/cphi -n(k,2)/cphi   n(k,1) | </span>
    <span class="c1">#                           | -n(k,2)*n(k,3)/cphi  n(k,1)/cphi   n(k,2) |  </span>
    <span class="c1">#                           |  cphi                0             n(k,3) | </span>
    <span class="c1">#                [x, y, z] @ R</span>
        
    <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[[</span> <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">cphi</span> <span class="p">,</span>  <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">cphi</span>        <span class="p">,</span>  <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span>  
                   <span class="p">[</span> <span class="o">-</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">cphi</span> <span class="p">,</span>   <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">cphi</span>        <span class="p">,</span>  <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span> <span class="p">,</span>
                   <span class="p">[</span>                    <span class="n">cphi</span> <span class="p">,</span>   <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">cphi</span><span class="p">)</span>  <span class="p">,</span>  <span class="n">n</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">]</span> <span class="p">]</span> <span class="p">)</span>  
    <span class="k">if</span> <span class="n">R</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="covtransform">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.covtransform.html#pymgp.crstrans.covtransform">[docs]</a>
<span class="k">def</span> <span class="nf">covtransform</span><span class="p">(</span><span class="n">qin</span><span class="p">,</span> <span class="n">fmtin</span><span class="p">,</span> <span class="n">fmtout</span><span class="p">,</span> <span class="n">rotmatrix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform and reformat compact co-variance matrices/vectors.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    qin : array_like shape (...,6) or shape (...,3,3) </span>
<span class="sd">        Input (compact) co-variance matrix/vector.</span>
<span class="sd">    fmtin : str</span>
<span class="sd">        Format of the input compact co-variance matrix/vector, see notes.</span>
<span class="sd">    fmtout : str</span>
<span class="sd">        Format of the output compact co-variance matrix/vector, see notes.</span>
<span class="sd">    rotmatrix : array_like with shape (...,3,3), default=None</span>
<span class="sd">        Optional rotation matrix to obtain ``Qout = R.T @ Qin @ R`` .         </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    qout : ndarray with shape (...,6) or shape (...,3,3)</span>
<span class="sd">        Output (compact) co-variance matrix/vector.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Supported input and output (compact) &quot;co-variance&quot; matrix/vector formats are::</span>

<span class="sd">      qmat    matrix [ [ qx qxy qxz ] </span>
<span class="sd">                       [ qxy qy qyz ] </span>
<span class="sd">                       [ qxy qyz qz ] ]</span>

<span class="sd">      qvec    vector [ qx, qy, qz, qxy, qxz, qyz ]</span>
<span class="sd">      scor    vector [ sx, sy, sz, rxy, rxz, ryz ]    (geo++, NRCAN)</span>
<span class="sd">      scof    vector [ sx, sy, sz, cxy, cxz, cyz ]    (gamit/globk)</span>
<span class="sd">      scov    vector [ sx, sy, sz, sxy, sxz, syz ]</span>
<span class="sd"> </span>
<span class="sd">      qvecd   vector [ qx, qy, qz, qxy, qyz, qxz ] </span>
<span class="sd">      scord   vector [ sx, sy, sz, rxy, ryz, rxz ]    </span>
<span class="sd">      scofd   vector [ sx, sy, sz, cxy, cyz, cxz ]    </span>
<span class="sd">      scovd   vector [ sx, sy, sz, sxy, syz, sxz ]    (rtklib)</span>
<span class="sd"> </span>
<span class="sd">    with ``si=sqrt(qi)``, ``rij=qij/(sqrt(qi)*sqrt(qj))``, ``cij=sign(rij)*sqrt(abs(rij))`` </span>
<span class="sd">    and ``sij=sign(qij)*sqrt(abs(qij))``. </span>
<span class="sd">    </span>
<span class="sd">    The vector formats ending with &quot;d&quot; are store by diagonal, as is illustrated by::</span>
<span class="sd">    </span>
<span class="sd">        qmat = [[ 1 4 6 ]   -&gt;  qvecd = [ 1 2 3 4 5 6 ]  -&gt;  qvec = [ 1 2 3 4 6 5] </span>
<span class="sd">                [ 4 2 5 ]                                                     |_|</span>
<span class="sd">                [ 6 5 3 ]] </span>
<span class="sd">    </span>
<span class="sd">    The other vector formats have their last two positions swapped compared to the </span>
<span class="sd">    store by diagonal formats.</span>

<span class="sd">    The input rotation matrix is transposed compared to what is often found in literature and what is</span>
<span class="sd">    used by the Matlab versions. This is intentional, as the rotation matrix from `xyz2neu` and `neu2xyz`</span>
<span class="sd">    is defined by::</span>
<span class="sd">    </span>
<span class="sd">        xout = xin @ R</span>
<span class="sd">        qout = R.T @ qin @ R </span>

<span class="sd">    These equations can only be used for the most simple use cases with simple shapes and is NOT </span>
<span class="sd">    recommended for coding. Instead, Einstein summation is used in this function::</span>
<span class="sd">    </span>
<span class="sd">        xout = np.einsum(&#39;...j,...ji&#39;,xin, R)</span>
<span class="sd">        </span>
<span class="sd">        tmp = np.einsum(&#39;...ij, ...jk -&gt; ...ik&#39;, qin, R)</span>
<span class="sd">        qout = np.einsum(&#39;...ji, ...jk -&gt; ...ik&#39;, R, tmp)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    xyz2neu, neu2xyz, printcrd, ellrotmatrix</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Examples reformatting compact co-variance matrices</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; covtransform([ 0.2061, 0.0708, 0.6352, -0.0109, 0.1514, -0.0188 ], &#39;scovd&#39;, &#39;qmat&#39;)</span>
<span class="sd">    array([[ 4.2477210e-02, -1.1881000e-04, -3.5344000e-04],</span>
<span class="sd">           [-1.1881000e-04,  5.0126400e-03,  2.2921960e-02],</span>
<span class="sd">           [-3.5344000e-04,  2.2921960e-02,  4.0347904e-01]])</span>

<span class="sd">    &gt;&gt;&gt; covtransform([[ 1, 2, 3, 0.4, 0.5, -0.6], [ 2, 1, 3, 0.5, 0.4, -0.6]], &#39;scord&#39;,&#39;qvec&#39;)</span>
<span class="sd">    array([[ 1. ,  4. ,  9. ,  0.8, -1.8,  3. ],</span>
<span class="sd">           [ 4. ,  1. ,  9. ,  1. , -3.6,  1.2]])</span>

<span class="sd">    Example transforming compact xyz co-variance matrix into neu compact covariance matrix,</span>
<span class="sd">    using example data from NRCAN PPP processing</span>

<span class="sd">    &gt;&gt;&gt; xyz = [ 3923153.4730, 327268.0593, 5001437.4151 ]</span>
<span class="sd">    &gt;&gt;&gt; plh = [ 51+58/60+46.39902/3600, 4+46/60+6.78968/3600,  44.3163]</span>
<span class="sd">    &gt;&gt;&gt; scorxyz = [ 0.0049, 0.0020, 0.0058, 0.1538,  0.8101,  0.1681 ]</span>
<span class="sd">    &gt;&gt;&gt; scorneu = [ 0.0023, 0.0020, 0.0072, 0.0357, -0.0769, -0.0086 ]</span>

<span class="sd">    &gt;&gt;&gt; neu, R = xyz2neu(xyz, plh, unit=&#39;deg&#39;, origin=&#39;ecef&#39;, rotmatrix=&#39;true&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(R)</span>
<span class="sd">    [[-0.78506419 -0.0831309   0.61381062]</span>
<span class="sd">     [-0.06548977  0.99653864  0.05120386]</span>
<span class="sd">     [ 0.61594262  0.          0.78779102]]</span>

<span class="sd">    &gt;&gt;&gt; scorneu_test = covtransform(scorxyz,fmtin=&#39;scor&#39;,fmtout=&#39;scor&#39;,rotmatrix=R)</span>
<span class="sd">    &gt;&gt;&gt; print(np.round(scorneu_test,4))</span>
<span class="sd">    [ 0.0023  0.002   0.0072  0.0337 -0.0572 -0.0058]</span>
<span class="sd">    &gt;&gt;&gt; print(np.round(scorneu_test - scorneu,4))</span>
<span class="sd">    [ 0.     -0.      0.     -0.002   0.0197  0.0028]</span>
<span class="sd">     </span>
<span class="sd">    &quot;&quot;&quot;</span> 

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Created:     8 March 2014 by Hans van der Marel for Malab</span>
<span class="sd">    Modified:   11 July 2018 by Hans van der Marel</span>
<span class="sd">                 - new formats scof and scofd (square root of correlation)</span>
<span class="sd">                21 July 2024 by Hans van der Marel</span>
<span class="sd">                 - Port to Python</span>
<span class="sd">                 </span>
<span class="sd">    Based on code originally developed for Matlab(TM) in 2014 and 2018 by the author.</span>

<span class="sd">    Copyright Hans van der Marel, Delft University of Technology, 2024</span>
<span class="sd">    &quot;&quot;&quot;</span>
  
    <span class="c1"># Check input and output formats</span>
    <span class="k">assert</span> <span class="n">fmtin</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;qmat&#39;</span> <span class="p">,</span><span class="s1">&#39;qvec&#39;</span><span class="p">,</span> <span class="s1">&#39;scor&#39;</span><span class="p">,</span> <span class="s1">&#39;scof&#39;</span> <span class="p">,</span><span class="s1">&#39;scov&#39;</span><span class="p">,</span> <span class="s1">&#39;qvecd&#39;</span> <span class="p">,</span><span class="s1">&#39;scord&#39;</span><span class="p">,</span> <span class="s1">&#39;scofd&#39;</span><span class="p">,</span> <span class="s1">&#39;scovd&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported input format </span><span class="si">{</span><span class="n">fmtin</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">assert</span> <span class="n">fmtout</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;qmat&#39;</span> <span class="p">,</span><span class="s1">&#39;qvec&#39;</span><span class="p">,</span> <span class="s1">&#39;scor&#39;</span><span class="p">,</span> <span class="s1">&#39;scof&#39;</span> <span class="p">,</span><span class="s1">&#39;scov&#39;</span><span class="p">,</span> <span class="s1">&#39;qvecd&#39;</span> <span class="p">,</span><span class="s1">&#39;scord&#39;</span><span class="p">,</span> <span class="s1">&#39;scofd&#39;</span><span class="p">,</span> <span class="s1">&#39;scovd&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported output format </span><span class="si">{</span><span class="n">fmtout</span><span class="si">}</span><span class="s2">.&quot;</span>
    
    <span class="c1"># Force input array to ndarray and check the shape</span>
    
    <span class="n">qin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">qin</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fmtin</span> <span class="o">==</span> <span class="s1">&#39;qmat&#39;</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">qin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="o">&amp;</span> <span class="n">qin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">,</span> <span class="s2">&quot;Input co-variance matrix must be 3-by-3.&quot;</span> 
        <span class="c1"># ndim = qin.ndim - 2</span>
        <span class="n">nshape</span> <span class="o">=</span> <span class="n">qin</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">qin</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span> <span class="p">,</span> <span class="s2">&quot;Input compact co-variance matrix must have six elements.&quot;</span> 
        <span class="c1"># ndim = qin.ndim - 1</span>
        <span class="n">nshape</span> <span class="o">=</span> <span class="n">qin</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        

    <span class="c1"># Convert input into intermediate qvec format</span>

    <span class="n">qvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">nshape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">6</span><span class="p">,)</span> <span class="p">)</span>

    <span class="k">if</span> <span class="n">fmtin</span> <span class="o">==</span> <span class="s1">&#39;qmat&#39;</span><span class="p">:</span>
        <span class="c1"># convert matrix format to qvec format</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">qin</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">qin</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">qin</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="n">qin</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">qin</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="n">qin</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">qin</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="n">qin</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">qin</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">fmttmp</span> <span class="o">=</span> <span class="s1">&#39;qvec&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">qvec</span> <span class="o">=</span> <span class="n">qin</span>
        <span class="n">fmttmp</span> <span class="o">=</span> <span class="n">fmtin</span>

    <span class="k">if</span> <span class="n">fmttmp</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;qvecd&#39;</span><span class="p">,</span> <span class="s1">&#39;scord&#39;</span><span class="p">,</span> <span class="s1">&#39;scofd&#39;</span><span class="p">,</span> <span class="s1">&#39;scovd&#39;</span><span class="p">]:</span> 
        <span class="c1"># interchange order of elements</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>
        <span class="n">fmttmp</span> <span class="o">=</span> <span class="n">fmttmp</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
    <span class="k">if</span> <span class="n">fmttmp</span> <span class="o">==</span> <span class="s1">&#39;scor&#39;</span><span class="p">:</span>
        <span class="c1"># sdx sdy sdz rxy rxz ryz</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> 
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">elif</span> <span class="n">fmttmp</span> <span class="o">==</span> <span class="s1">&#39;scof&#39;</span><span class="p">:</span>
        <span class="c1"># sdx sdy sdz cxy cxz cyz</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>  <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> 
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">elif</span> <span class="n">fmttmp</span> <span class="o">==</span> <span class="s1">&#39;scov&#39;</span><span class="p">:</span>
        <span class="c1"># sdx sdy sdz sdxy sdxz sdyz</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> 
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> 
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> 
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1"># Convert qvec into matrix if required for output or transformation with rotation matrix</span>

    <span class="k">if</span> <span class="n">fmtout</span> <span class="o">==</span> <span class="s1">&#39;qmat&#39;</span> <span class="ow">or</span> <span class="n">rotmatrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fmtin</span> <span class="o">==</span> <span class="s1">&#39;qmat&#39;</span><span class="p">:</span>
            <span class="n">qout</span> <span class="o">=</span> <span class="n">qin</span>    
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># convert qvec format into matrix</span>
            <span class="n">qout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span> <span class="n">nshape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">,)</span> <span class="p">)</span>
            <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> 
            <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> 
            <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> 
            <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> 
            <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
            <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> 
            <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>

    <span class="c1"># Transform (rotate) the co-variance matrix  Qout = R @ Qin @ R.T</span>

    <span class="k">if</span> <span class="n">rotmatrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Compute &quot;qout = R.T @ qout @ R&quot; using einstein summation, matrix multiplication</span>
        <span class="c1"># with &quot;@&quot; does not work for dimensions &gt; 2. Einstein summation allows to specify</span>
        <span class="c1"># broadcasting rules through ellipses.</span>
        <span class="c1">#</span>
        <span class="c1"># Note: The computation could be made more efficient (1) because the co-variance matrices</span>
        <span class="c1"># qin and qout are symmetric and (2) because we can replace the matrix operation</span>
        <span class="c1"># by operations directly on qvec. The matrix product &quot;qout = R.T @ qout @ R&quot; can</span>
        <span class="c1"># be written as </span>
        <span class="c1">#                  qout = sum_ij ( qin[i,j] * ( R[j,:].T @ R[i,:]) )</span>
        <span class="c1"># whereby R[j,:].T @ R[i,:] are outer products producing 3-by-3 matrices for each </span>
        <span class="c1"># non-redundant combination of i,j=0:3 . This is a fun fact only, the performance gain</span>
        <span class="c1"># is not noteworthy. </span>
        
        <span class="c1">#qout = np.einsum(&#39;...ij, ...kj -&gt; ...ik&#39;, qout, rotmatrix)</span>
        <span class="c1">#qout = np.einsum(&#39;...ij, ...jk -&gt; ...ik&#39;, rotmatrix, qout)</span>
        <span class="n">qout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...ij, ...jk -&gt; ...ik&#39;</span><span class="p">,</span> <span class="n">qout</span><span class="p">,</span> <span class="n">rotmatrix</span><span class="p">)</span>
        <span class="n">qout</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;...ji, ...jk -&gt; ...ik&#39;</span><span class="p">,</span> <span class="n">rotmatrix</span><span class="p">,</span> <span class="n">qout</span><span class="p">)</span>

        <span class="k">if</span>  <span class="n">fmtout</span> <span class="o">!=</span> <span class="s1">&#39;qmat&#39;</span><span class="p">:</span>
            <span class="c1"># convert matrix format to qvec format (if required)</span>
            <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span> <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">qout</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># Return co-variance in matrix format (if requested)</span>
    
    <span class="k">if</span> <span class="n">fmtout</span> <span class="o">==</span> <span class="s1">&#39;qmat&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">qout</span>
        
    <span class="c1"># Convert intermediate qvec format into output vector format </span>
  
    <span class="k">if</span> <span class="n">fmtout</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;scor&#39;</span><span class="p">,</span> <span class="s1">&#39;scord&#39;</span><span class="p">]:</span>
        <span class="c1"># sdx sdy sdz rxy rxz ryz</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> 
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span>
    <span class="k">elif</span> <span class="n">fmtout</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;scof&#39;</span><span class="p">,</span> <span class="s1">&#39;scofd&#39;</span><span class="p">]:</span>
        <span class="c1"># sdx sdy sdz cxy cxz cyz</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>  
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="p">)</span> <span class="p">)</span>
    <span class="k">elif</span> <span class="n">fmtout</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;scov&#39;</span><span class="p">,</span> <span class="s1">&#39;scovd&#39;</span><span class="p">]:</span>
        <span class="c1"># sdx sdy sdz sdxy sdxz sdyz</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">]))</span> 
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">4</span><span class="p">]))</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">5</span><span class="p">]))</span>

    <span class="k">if</span> <span class="n">fmtout</span> <span class="ow">in</span> <span class="p">[</span> <span class="s1">&#39;qvecd&#39;</span><span class="p">,</span> <span class="s1">&#39;scord&#39;</span><span class="p">,</span> <span class="s1">&#39;scofd&#39;</span><span class="p">,</span> <span class="s1">&#39;scovd&#39;</span><span class="p">]:</span> 
        <span class="c1"># interchange order of elements</span>
        <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]]</span> <span class="o">=</span> <span class="n">qvec</span><span class="p">[</span><span class="o">...</span><span class="p">,[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">qvec</span></div>

 
<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#                          PRINT FUNCTIONS</span>
<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1">#   printcrd     - Print a table with coordinates and optional co-variances</span>
<span class="c1">#   printxyz     - Print array with cartesian coordinates</span>
<span class="c1">#   printplh     - Print array with geodetic/ellipsoidal coordinates </span>
<span class="c1">#   deg2dms      - Convert latitude/longitude to degree, minute, second notation</span>

<div class="viewcode-block" id="printcrd">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.printcrd.html#pymgp.crstrans.printcrd">[docs]</a>
<span class="k">def</span> <span class="nf">printcrd</span><span class="p">(</span><span class="n">crd</span><span class="p">,</span> <span class="n">prtfmt</span><span class="o">=</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="p">[],</span> <span class="n">sdcov</span><span class="o">=</span><span class="p">[],</span> <span class="n">sdcovfmt</span><span class="o">=</span><span class="s2">&quot;std&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad/m&#39;</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print a table with coordinates and optional standard deviation/co-variance information.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    crd : array_like with shape (...,3) </span>
<span class="sd">        Array with Cartesian or geographic coordinates.</span>
<span class="sd">    prtfmt : {&#39;xyz&#39;, &#39;neu&#39;,&#39;map&#39;, &#39;plh&#39;, &#39;dms&#39;,&#39;dmspretty&#39;, ...}, default=&#39;xyz&#39;</span>
<span class="sd">        Coordinate format for printing.</span>
<span class="sd">        </span>
<span class="sd">        - &#39;xyz&#39; (&#39;ecef&#39;):  Cartesian XYZ coordinates (default)</span>
<span class="sd">        - &#39;neu&#39; (&#39;local&#39;): Coordinates in local NEU system</span>
<span class="sd">        - &#39;map&#39;: Coordinates in map projection system</span>
<span class="sd">        - &#39;plh&#39; (&#39;geodetic&#39;): Geographic coordinates printed in decimal degrees</span>
<span class="sd">        - &#39;dms&#39; (&#39;sexagesimal&#39;): Geographic coordiantes printed in degrees, minutes, seconds. </span>
<span class="sd">        - &#39;dmspretty&#39;: As &#39;dms&#39;, with degree, minute and second symbols.</span>
<span class="sd">        </span>
<span class="sd">        For the options &#39;dms&#39;, &#39;dmspretty&#39; and &#39;plh&#39; `crd` must contain the latitude and </span>
<span class="sd">        longitude in either radians or degrees (with unit=&#39;deg/m&#39;)</span>
<span class="sd">    labels : array_like, optional</span>
<span class="sd">        Optional list with row labels, e.g. station names.        </span>
<span class="sd">    sdcov : array_like with shape (...,3) or shape (...,6) </span>
<span class="sd">        Optional standard deviations (...,3) and/or co-variances (...,6). </span>
<span class="sd">    sdcovfmt : {&#39;std&#39;, &#39;qvec&#39;, &#39;scor&#39;, &#39;scov&#39;, ...}, optional</span>
<span class="sd">        Format of the input compact co-variance matrix/vector, see `covtransform` for</span>
<span class="sd">        all for possible formats. Default is &#39;std&#39;</span>
<span class="sd">    unit : {&#39;rad/m&#39;, &#39;deg/m&#39;, &#39;deg&#39;, &#39;rad&#39;}, optional</span>
<span class="sd">        Units of input `crd` array, , default &#39;rad/m&#39;.</span>
<span class="sd">    title : str, optional</span>
<span class="sd">        Optional title string.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        Nothing to return.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Create a test case</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; crd = np.array([[ 1, 2, 3 ] , [ 4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; sdcov = np.hstack((crd,crd))</span>
<span class="sd">    &gt;&gt;&gt; station = [ &#39;DELF&#39; , &#39;Stolwijk&#39;]</span>
<span class="sd">    </span>
<span class="sd">    Basic examples without much additional information</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; printcrd(crd, prtfmt=&#39;map&#39;)</span>
<span class="sd">              x[m]          y[m]        h[m]</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">            1.0000        2.0000      3.0000</span>
<span class="sd">            4.0000        5.0000      6.0000</span>
<span class="sd">            </span>
<span class="sd">    &gt;&gt;&gt; printcrd(crd, prtfmt=&#39;dmspretty&#39;, unit=&#39;deg&#39;)</span>
<span class="sd">             Lat[dms]        Lon[dms]       H[m]</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">        1°00&#39;00.0000&quot;   2°00&#39;00.0000&quot;     3.0000</span>
<span class="sd">        4°00&#39;00.0000&quot;   5°00&#39;00.0000&quot;     6.0000</span>

<span class="sd">    More elaborate examples with labels, standard deviations and covariance information</span>
<span class="sd">        </span>
<span class="sd">    &gt;&gt;&gt; printcrd(crd, prtfmt=&#39;xyz&#39;, labels=station, sdcov=sdcov, sdcovfmt=&quot;std&quot;)  </span>
<span class="sd">                        X[m]            Y[m]            Z[m]      sx[m]    sy[m]    sz[m]</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    DELF              1.0000          2.0000          3.0000     1.0000   2.0000   3.0000</span>
<span class="sd">    Stolwijk          4.0000          5.0000          6.0000     4.0000   5.0000   6.0000</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; printcrd(crd, prtfmt=&#39;plh&#39;, labels=station, sdcov=sdcov, sdcovfmt=&quot;qvec&quot;, unit=&#39;deg&#39;)</span>
<span class="sd">                    Lat[deg]        Lon[deg]       H[m]      sn[m]    se[m]    su[m]   sne[m]   snu[m]   seu[m]</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">    DELF         1.000000000     2.000000000     3.0000     1.0000   1.0000   1.0000   1.0000   1.0000   1.0000</span>
<span class="sd">    Stolwijk     4.000000000     5.000000000     6.0000     2.0000   2.0000   2.0000   2.0000   2.0000   2.0000</span>
<span class="sd">     </span>
<span class="sd">    &quot;&quot;&quot;</span> 

    <span class="c1"># Force input array to ndarray and check the first twp parameters </span>
    <span class="n">crd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">crd</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">crd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">,</span> <span class="s2">&quot;Coordinate vector must have three coordinates.&quot;</span> 
    <span class="k">assert</span> <span class="n">prtfmt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ecef&#39;</span><span class="p">,</span> <span class="s1">&#39;xyz&#39;</span><span class="p">,</span> <span class="s1">&#39;local&#39;</span><span class="p">,</span> <span class="s1">&#39;neu&#39;</span><span class="p">,</span> <span class="s1">&#39;map&#39;</span><span class="p">,</span> <span class="s1">&#39;geodetic&#39;</span><span class="p">,</span> <span class="s1">&#39;plh&#39;</span><span class="p">,</span> <span class="s1">&#39;sexagesimal&#39;</span><span class="p">,</span> <span class="s1">&#39;dms&#39;</span><span class="p">,</span> <span class="s1">&#39;dmspretty&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported print format </span><span class="si">{</span><span class="n">prtfmt</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">assert</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rad/m&#39;</span><span class="p">,</span> <span class="s1">&#39;deg/m&#39;</span><span class="p">,</span> <span class="s1">&#39;deg&#39;</span><span class="p">,</span> <span class="s1">&#39;rad&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported unit </span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">.&quot;</span>

    <span class="c1"># Check optional labels</span>
    <span class="n">labels</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">labels</span><span class="o">.</span><span class="n">size</span>  <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">crd</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">labels</span><span class="o">.</span><span class="n">shape</span> <span class="p">,</span> <span class="s2">&quot;Station list size does not match coordinate list.&quot;</span> 

    <span class="c1"># Check standard deviation / covariances</span>
    <span class="n">sdcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sdcov</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">sdcov</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">sdcov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">sdcov</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span><span class="p">,</span> <span class="s2">&quot;sdcov must have 3 or 6 elements in each item.&quot;</span> 
        <span class="k">assert</span> <span class="n">sdcov</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">crd</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span> <span class="s2">&quot;Sdcov size does not match crd size.&quot;</span> 
        <span class="c1"># covfmt will be asserted later</span>

    <span class="c1"># Prepare header and format strings</span>

    <span class="k">if</span> <span class="n">prtfmt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="p">,</span> <span class="s1">&#39;ecef&#39;</span><span class="p">]:</span>
        <span class="n">crdheader</span> <span class="o">=</span> <span class="s1">&#39;            X[m]            Y[m]            Z[m]&#39;</span>
        <span class="n">covheader</span> <span class="o">=</span> <span class="s1">&#39;      sx[m]    sy[m]    sz[m]   sxy[m]   sxz[m]   syz[m]&#39;</span>
        <span class="n">crdstr</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:&gt;16.4f}{:&gt;16.4f}{:&gt;16.4f}</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">prtfmt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;neu&#39;</span><span class="p">,</span> <span class="s1">&#39;local&#39;</span><span class="p">]:</span>
        <span class="n">crdheader</span> <span class="o">=</span> <span class="s1">&#39;        N[m]        E[m]        U[m]&#39;</span>
        <span class="n">covheader</span> <span class="o">=</span> <span class="s1">&#39;      sn[m]    se[m]    su[m]   sne[m]   snu[m]   seu[m]&#39;</span>
        <span class="n">crdstr</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:&gt;12.4f}{:&gt;12.4f}{:&gt;12.4f}</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">prtfmt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]:</span>
        <span class="n">crdheader</span> <span class="o">=</span> <span class="s1">&#39;          x[m]          y[m]        h[m]&#39;</span>
        <span class="n">covheader</span> <span class="o">=</span> <span class="s1">&#39;      sx[m]    sy[m]    sh[m]   sxy[m]   sxh[m]   syh[m]&#39;</span>
        <span class="n">crdstr</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:&gt;14.4f}{:&gt;14.4f}{:&gt;12.4f}</span><span class="s1">&#39;</span> 
    <span class="k">elif</span> <span class="n">prtfmt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;plh&#39;</span><span class="p">,</span> <span class="s1">&#39;geodetic&#39;</span><span class="p">]:</span>
        <span class="n">crdheader</span> <span class="o">=</span> <span class="s1">&#39;        Lat[deg]        Lon[deg]       H[m]&#39;</span>
        <span class="n">covheader</span> <span class="o">=</span> <span class="s1">&#39;      sn[m]    se[m]    su[m]   sne[m]   snu[m]   seu[m]&#39;</span>
        <span class="n">crdstr</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:&gt;16.9f}{:&gt;16.9f}{:&gt;11.4f}</span><span class="s1">&#39;</span>
    <span class="k">elif</span> <span class="n">prtfmt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dms&#39;</span><span class="p">,</span> <span class="s1">&#39;sexagesimal&#39;</span><span class="p">,</span> <span class="s1">&#39;dmspretty&#39;</span><span class="p">]:</span>
        <span class="n">crdheader</span> <span class="o">=</span> <span class="s1">&#39;         Lat[dms]        Lon[dms]       H[m]&#39;</span>
        <span class="n">covheader</span> <span class="o">=</span> <span class="s1">&#39;      sn[m]    se[m]    su[m]   sne[m]   snu[m]   seu[m]&#39;</span>
        <span class="n">crdstr</span> <span class="o">=</span> <span class="s1">&#39; </span><span class="si">{:&gt;16s}{:&gt;16s}{:&gt;11.4f}</span><span class="s1">&#39;</span>
        <span class="k">if</span> <span class="n">prtfmt</span> <span class="o">==</span> <span class="s1">&#39;dmspretty&#39;</span><span class="p">:</span>
            <span class="n">pretty</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pretty</span><span class="o">=</span><span class="kc">False</span>

    <span class="c1"># Prepare co-variance header and format strings</span>

    <span class="k">if</span> <span class="n">sdcov</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sdcovfmt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;std&#39;</span><span class="p">]:</span>
           <span class="n">covheader</span> <span class="o">=</span> <span class="n">covheader</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">29</span><span class="p">]</span>
           <span class="n">covstr</span> <span class="o">=</span> <span class="s1">&#39;  </span><span class="si">{:&gt;9.4f}{:&gt;9.4f}{:&gt;9.4f}</span><span class="s1">&#39;</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">sdcov</span> <span class="o">=</span> <span class="n">covtransform</span><span class="p">(</span><span class="n">sdcov</span><span class="p">,</span> <span class="n">sdcovfmt</span><span class="p">,</span> <span class="s1">&#39;scov&#39;</span><span class="p">)</span>
           <span class="n">covstr</span> <span class="o">=</span> <span class="s1">&#39;  </span><span class="si">{:&gt;9.4f}{:&gt;9.4f}{:&gt;9.4f}{:&gt;9.4f}{:&gt;9.4f}{:&gt;9.4f}</span><span class="s1">&#39;</span>
    <span class="k">else</span><span class="p">:</span>
       <span class="n">covheader</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
       <span class="n">covstr</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="c1"># Prepare label header and lenght</span>

    <span class="k">if</span> <span class="n">labels</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">labellength</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">str_len</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span>
        <span class="n">labelstr</span> <span class="o">=</span> <span class="s1">&#39;{:&#39;</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="si">{:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">labellength</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;s}&#39;</span>
        <span class="n">labelheader</span> <span class="o">=</span> <span class="n">labelstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">labelheader</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

    <span class="c1"># conversion factor for lat/lon</span>

    <span class="k">if</span> <span class="n">unit</span> <span class="o">==</span> <span class="s1">&#39;rad/m&#39;</span><span class="p">:</span>
        <span class="n">r2d</span><span class="o">=</span><span class="mf">180.</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r2d</span><span class="o">=</span><span class="mf">1.</span>
    
    <span class="c1"># Print headers</span>

    <span class="k">if</span> <span class="n">title</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>
    <span class="c1">#print(labelheader + crdheader + covheader)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">labelheader</span> <span class="o">+</span> <span class="n">crdheader</span> <span class="o">+</span> <span class="n">covheader</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># Print body</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">crd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">if</span> <span class="n">labelheader</span> <span class="o">!=</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span> <span class="o">+</span> <span class="n">labelstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">prtfmt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;dms&#39;</span><span class="p">,</span> <span class="s1">&#39;sexagesimal&#39;</span><span class="p">,</span> <span class="s1">&#39;dmspretty&#39;</span><span class="p">]:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span> <span class="o">+</span> <span class="n">crdstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">deg2dms</span><span class="p">(</span><span class="n">crd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">r2d</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;deg&#39;</span><span class="p">,</span> <span class="n">pretty</span><span class="o">=</span><span class="n">pretty</span><span class="p">),</span><span class="n">deg2dms</span><span class="p">(</span><span class="n">crd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">r2d</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;deg&#39;</span><span class="p">,</span><span class="n">pretty</span><span class="o">=</span><span class="n">pretty</span><span class="p">),</span><span class="n">crd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>    
        <span class="k">elif</span> <span class="n">prtfmt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;plh&#39;</span><span class="p">,</span> <span class="s1">&#39;geodetic&#39;</span><span class="p">]:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span> <span class="o">+</span> <span class="n">crdstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">crd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">r2d</span><span class="p">,</span><span class="n">crd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">r2d</span><span class="p">,</span><span class="n">crd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>    
        <span class="k">else</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span> <span class="o">+</span> <span class="n">crdstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">crd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">crd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">crd</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>   
        <span class="k">if</span> <span class="n">sdcov</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sdcovfmt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;std&#39;</span><span class="p">]:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span> <span class="o">+</span> <span class="n">covstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sdcov</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">sdcov</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">sdcov</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span> <span class="o">+</span> <span class="n">covstr</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">sdcov</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">sdcov</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">sdcov</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="n">sdcov</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="n">sdcov</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span><span class="n">sdcov</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="k">return</span></div>


<div class="viewcode-block" id="printxyz">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.printxyz.html#pymgp.crstrans.printxyz">[docs]</a>
<span class="k">def</span> <span class="nf">printxyz</span><span class="p">(</span><span class="n">xyz</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print Cartesian coordinates in fixed format with 0.1 mm precision.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xyz : array_like with shape (...,3) </span>
<span class="sd">        Cartesian coordinates.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        Nothing to return.</span>
<span class="sd">        </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; printxyz([4123456.23000, 0.3, 0.123451])</span>
<span class="sd">    [ 4123456.2300  0.3000  0.1235]</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">printoptions</span><span class="p">(</span><span class="n">formatter</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;float&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="si">{: 0.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">},</span> <span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>

    <span class="k">return</span></div>

    
<div class="viewcode-block" id="printplh">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.printplh.html#pymgp.crstrans.printplh">[docs]</a>
<span class="k">def</span> <span class="nf">printplh</span><span class="p">(</span><span class="n">plh</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad/m&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print Geographic (Lat, Lon, Height) coordinates in fixed format with 0.1 mm precision.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    plh : array_like with shape (...,3) </span>
<span class="sd">        Ellipsoidal coordinates (geographic latitude, longitude and height above the ellipsoid).</span>
<span class="sd">    unit : {&#39;rad/m&#39;, &#39;deg/m&#39;, &#39;rad&#39;, &#39;deg&#39;},  default = &#39;rad/m&#39;</span>
<span class="sd">        Units for the input latitude and longitude (and height).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        Nothing to return.</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    One degree is about 111 km, one millidegree (10^-3) is about 111 m, one micro degree </span>
<span class="sd">    (10^-6) is 0.111 m,  one pico degree (10^-9)  is 0.111 mm, so 9 digits will do</span>
<span class="sd">    for the latitude and longitude, and 4 digits for the height.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; printplh([52.1234567891, 4., 110.000001], unit=&#39;deg&#39;)</span>
<span class="sd">    [ 52.12345679   4.         110.        ]</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">tmp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">plh</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">tmp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">,</span> <span class="s2">&quot;Ellipsoidal coordinate vector(s) plh must have three coordinates (Latitude, longitude, height).&quot;</span> 
    <span class="k">assert</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rad/m&#39;</span> <span class="p">,</span><span class="s1">&#39;deg/m&#39;</span><span class="p">,</span> <span class="s1">&#39;rad&#39;</span> <span class="p">,</span><span class="s1">&#39;deg&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported unit </span><span class="si">{</span><span class="n">unit</span><span class="si">}</span><span class="s2">.&quot;</span>
    <span class="k">if</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="s1">&#39;rad/m&#39;</span><span class="p">]:</span>
        <span class="n">tmp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="n">tmp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span><span class="mi">9</span><span class="p">)</span>
    <span class="n">tmp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="mi">4</span><span class="p">)</span>
    
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">printoptions</span><span class="p">(</span><span class="n">suppress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>

    <span class="k">return</span></div>


<div class="viewcode-block" id="deg2dms">
<a class="viewcode-back" href="../../reference/generated/pymgp.crstrans.deg2dms.html#pymgp.crstrans.deg2dms">[docs]</a>
<span class="k">def</span> <span class="nf">deg2dms</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">pretty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s1">&#39;rad&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert latitude/longitude angles into a string with degrees, minutes and second format.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    value : float</span>
<span class="sd">        Value to convert.</span>
<span class="sd">    unit : {&#39;rad&#39;, &#39;deg&#39;, &#39;rad/m&#39;, &#39;deg/m&#39;},  optional, default = &#39;rad&#39;</span>
<span class="sd">        Unit of the values (only &#39;rad&#39; and &#39;deg&#39; are meaningful).</span>
<span class="sd">    pretty : boolean, optional, default=False</span>
<span class="sd">        Pretty print with degree, minute and second symbol.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dms : str</span>
<span class="sd">        Sring with output in dms format.</span>

<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    One degree is about 111 km along the meridian, one minute is 1850 m (one nautical mile), one </span>
<span class="sd">    second is 31 m, one milliarcsecond (mas) is 31 mm. The print resolution for the latitude, or</span>
<span class="sd">    longitude at the equator, is 0.01 mas, or 0.31 mm, in normal mode, and  0.1 mas, or 3.1 mm, </span>
<span class="sd">    in pretty print mode. </span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; deg2dms(0.9)</span>
<span class="sd">    &#39; 51 34 58.32562&#39;</span>

<span class="sd">    &gt;&gt;&gt; print(deg2dms(23.234567, unit=&#39;deg&#39;, pretty=True))</span>
<span class="sd">     23°14&#39;04.4412&quot;</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">unit</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;rad&#39;</span><span class="p">,</span> <span class="s1">&#39;rad/m&#39;</span><span class="p">]:</span>
        <span class="n">value1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">value1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="n">value3</span> <span class="o">=</span> <span class="p">(</span> <span class="n">value1</span> <span class="o">*</span> <span class="mi">3600</span> <span class="p">)</span>  <span class="o">%</span> <span class="mi">60</span>
    <span class="n">value2</span> <span class="o">=</span> <span class="p">(</span> <span class="n">value1</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span> <span class="o">%</span> <span class="mi">60</span>
    <span class="n">value1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">value1</span><span class="o">-</span><span class="n">value2</span><span class="o">/</span><span class="mi">60</span><span class="o">-</span><span class="n">value3</span><span class="o">/</span><span class="mi">3600</span><span class="p">)</span>  

    <span class="k">if</span> <span class="n">pretty</span><span class="p">:</span>
        <span class="n">dms</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{:&gt;3.0f}</span><span class="se">\xb0</span><span class="si">{:02.0f}</span><span class="se">\x27</span><span class="si">{:&gt;07.4f}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">,</span> <span class="n">value3</span><span class="p">)</span>
        <span class="c1">#dms=&#39;{:&gt;3.0f}\xb0{:02.0f}\x60{:&gt;07.4f}&quot;&#39;.format(value1, value2, value3)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dms</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{:&gt;3.0f}</span><span class="s1"> </span><span class="si">{:02.0f}</span><span class="s1"> </span><span class="si">{:&gt;07.5f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">,</span> <span class="n">value3</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dms</span></div>

    
</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
      © Copyright 2025, Hans van der Marel.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>