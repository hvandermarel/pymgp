
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pymgp.satorb &#8212; pyMGP 0.9 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!--
    this give us a css class that will be invisible only if js is disabled
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8878045cc6db502f8baf" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=8878045cc6db502f8baf"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf" />

    <script src="../../_static/documentation_options.js?v=049aceee"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/pymgp/satorb';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
  <button class="pst-navbar-icon sidebar-toggle primary-toggle" aria-label="Site navigation">
    <span class="fa-solid fa-bars"></span>
  </button>
  
  
  <div class="col-lg-3 navbar-header-items__start">
    
      <div class="navbar-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
  
    <p class="title logo__title">pyMGP 0.9 documentation</p>
  
</a></div>
    
  </div>
  
  <div class="col-lg-9 navbar-header-items">
    
    <div class="me-auto navbar-header-items__center">
      
        <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../usage.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../release.html">
    Release notes
  </a>
</li>

  </ul>
</nav></div>
      
    </div>
    
    
    <div class="navbar-header-items__end">
      
        <div class="navbar-item navbar-persistent--container">
          

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
        </div>
      
      
        <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
      
    </div>
    
  </div>
  
  
    <div class="navbar-persistent--mobile">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button>
    </div>
  

  
</div>

    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar hide-on-wide">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
      <div class="sidebar-header-items__center">
        
          
          
            <div class="navbar-item">
<nav>
  <ul class="bd-navbar-elements navbar-nav">
    
<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../usage.html">
    User Guide
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../api.html">
    API reference
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../examples.html">
    Examples
  </a>
</li>


<li class="nav-item ">
  <a class="nav-link nav-internal" href="../../release.html">
    Release notes
  </a>
</li>

  </ul>
</nav></div>
          
        
      </div>
    
    
    
      <div class="sidebar-header-items__end">
        
          <div class="navbar-item">

<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button></div>
        
      </div>
    
  </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
      <div class="sidebar-primary-item">
<div id="ethical-ad-placement"
      class="flat"
      data-ea-publisher="readthedocs"
      data-ea-type="readthedocs-sidebar"
      data-ea-manual="true">
</div></div>
  </div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        
          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item">

<nav aria-label="Breadcrumb" class="d-print-none">
  <ul class="bd-breadcrumbs">
    
    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>
    
    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>
    
    <li class="breadcrumb-item active" aria-current="page"><span class="ellipsis">pymgp.satorb</span></li>
  </ul>
</nav>
</div>
      
    </div>
  
  
</div>
</div>
              
              
              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for pymgp.satorb</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Satellite orbits.</span>

<span class="sd">Functions:</span>

<span class="sd">Keplerian elements</span>

<span class="sd">- vec2orb        Convert inertial state vector into Keplerian elements</span>
<span class="sd">- orb2vec        Convert Keplerian elements into inertial state vector</span>
<span class="sd">- orbtype        Classify circular and equatorial orbit types    </span>
<span class="sd">- kepler         Compute mean anomaly from eccentric anomaly (Kepler&#39;s equation)</span>
<span class="sd">- keplernu       Compute mean anomaly from true anomaly (Kepler&#39;s equation)</span>
<span class="sd">- keplerm        Compute eccentric/true from mean anomaly solving Kepler&#39;s eqn</span>

<span class="sd">UT1 to GMST, and ECI/ECEF, conversions</span>

<span class="sd">- ut2gmst        Compute Greenwich Mean Siderial Time from UT1</span>
<span class="sd">- ecef2eci       Convert position and velocity from ECEF to ECI reference frame</span>
<span class="sd">- eci2ecef       Convert position and velocity from ECI to ECEF reference frame</span>

<span class="sd">Look angles</span>
<span class="sd">    </span>
<span class="sd">- satlookanglesp Compute table with satellite look angles</span>
<span class="sd">- prtlookangle   Print a table with satellite look angles</span>

<span class="sd">Sequential date numbers</span>

<span class="sd">- datetime2num   Convert datestring, datetime or np.datetime64 to serial datenumber</span>
<span class="sd">- num2datetime64 Convert serial datenumber to np.datetime64</span>
<span class="sd">- num2datetime   Convert serial datenumber to datetime</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Hans van der Marel&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2010-2024, Hans van der Marel, Delft University of Technology.&quot;</span>
<span class="n">__credits__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Hans van der Marel&quot;</span><span class="p">,</span> <span class="s2">&quot;Simon van Diepen&quot;</span><span class="p">,</span> <span class="s2">&quot;Ullas Rajvanshi&quot;</span><span class="p">]</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;License Name and Info&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.9.0&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Hans van der Marel&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;h.vandermarel@tudelft.nl&quot;</span>
<span class="n">__status__</span> <span class="o">=</span> <span class="s2">&quot;development&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created:    16 Nov 2010 by Hans van der Marel for Matlab</span>
<span class="sd">Modified:   26 Nov 2016 by Hans van der Marel</span>
<span class="sd">             - added eci2ecef and ecef2eci to the Matlab version</span>
<span class="sd">            26 Jul 2017 by Hans van der Marel</span>
<span class="sd">             - created satlookangle function for matlab</span>
<span class="sd">             1 Nov 2017 by Hans van der Marel</span>
<span class="sd">             - satlookangle version for sperical angles for matlab</span>
<span class="sd">             - created prtlookangle (split off from satlookangle) for matlab</span>
<span class="sd">            18 Nov 2020 by Simon van Diepen, Ullas Rajvanshi and Hans van der Marel</span>
<span class="sd">             - port to Python (part of `crsutil` module)</span>
<span class="sd">            25 Nov 2021 by Hans van der Marel</span>
<span class="sd">             - added satlookanglesp, prtlookangle, datetime2num and num2datetime</span>
<span class="sd">            10 July 2024 by Hans van der Marel</span>
<span class="sd">               - added option for ellipsoidal or spherical angles to satlookangle,</span>
<span class="sd">               - satlookanglesp is now obsolete</span>
<span class="sd">            28 Jul 2024 by Hans van der Marel</span>
<span class="sd">             - functions vec2orb, orb2vec, kepler, keplernu, keplerm, ut2gmst, ecef2eci,</span>
<span class="sd">               eci2ecef, datetime2num, num2datetime, satlookangle and prtlookangle</span>
<span class="sd">               moved into new (this) module `satorb`</span>
<span class="sd">             - added new function `orbtype`</span>
<span class="sd">             - major rewrite with support for multidimension arrays</span>
<span class="sd">             - docstrings in numpy style</span>
<span class="sd">             - moved track changes sections from the individual functions to a</span>
<span class="sd">               single track changes section at the head of the module</span>
<span class="sd">            30 Jul 2024 by Hans van der Marel</span>
<span class="sd">             - rewrite of ut2gmst, removed dependency on datetime2num, using</span>
<span class="sd">               numpy datetime64 instead of datetime and parsedate</span>
<span class="sd">             - functions datetime2num and num2datetime rewritten using numpy </span>
<span class="sd">               datetime64 instead of Python datetime. </span>
<span class="sd">             - New function num2datetime64</span>
<span class="sd">             - import of dateutil.parser removed</span>
<span class="sd">            31 Jul 2024 by Hans van der Marel</span>
<span class="sd">             - major changes to satlookangle and prtlookangle, including</span>
<span class="sd">               modified docstring, and support for more dimensions, removed</span>
<span class="sd">               dependency on num2datetime</span>
<span class="sd">            22 Aug 2024 by Hans van der Marel</span>
<span class="sd">             - Major edits to the docstrings to facilitate sphynx</span>
<span class="sd">                                  </span>
<span class="sd">Based on code originally developed for Matlab(TM) in 2010-2016 by the author.</span>

<span class="sd">Copyright Hans van der Marel, Delft University of Technology, 2010-2024</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># Import modules</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">pymgp.crstrans</span> <span class="kn">import</span> <span class="n">xyz2plh</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>

<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#                            KEPLERIAN ELEMENTS</span>
<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1">#   vec2orb     - Convert inertial state vector into Keplerian elements</span>
<span class="c1">#   orb2vec     - Convert Keplerian elements into inertial state vector</span>
<span class="c1">#   orbtype     - Classify circular and equatorial orbit types    </span>
<span class="c1">#   kepler      - Compute mean anomaly from eccentric anomaly (Kepler&#39;s equation)</span>
<span class="c1">#   keplernu    - Compute mean anomaly from true anomaly (Kepler&#39;s equation)</span>
<span class="c1">#   keplerm     - Compute eccentric/true from mean anomaly solving Kepler&#39;s eqn</span>


<div class="viewcode-block" id="vec2orb">
<a class="viewcode-back" href="../../reference/generated/pymgp.satorb.vec2orb.html#pymgp.satorb.vec2orb">[docs]</a>
<span class="k">def</span> <span class="nf">vec2orb</span><span class="p">(</span><span class="n">svec</span><span class="p">,</span> <span class="n">GM</span><span class="o">=</span><span class="mf">3986004418e5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert inertial state vector into Keplerian elements.</span>
<span class="sd">    </span>
<span class="sd">    This function converts an array with 6-element inertial state vector(s), </span>
<span class="sd">    with cartesian position and velocity `[X, Y, Z, Xdot, Ydot, Zdot]`, into an </span>
<span class="sd">    array with the 6 Keplerian elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    svec : array_like with shape (...,6) </span>
<span class="sd">        Array with  6-element inertial state vector `svec` with Cartesian  </span>
<span class="sd">        position and velocity `[X, Y, Z, Xdot, Ydot, Zdot]` in an ECI frame.</span>
<span class="sd">        Units are meter and meter/sec</span>
<span class="sd">    GM : float, optional</span>
<span class="sd">        Value of GM. Default for GM [meter**3/sec**2] is the IERS 1996 standard</span>
<span class="sd">        value for the Earth (GM=3986004418e5)</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    orb : ndarray with shape (...,6) similar to `svec`</span>
<span class="sd">        Array with the 6 Keplerian elements `[ Semi-major axis (meters), Eccentricity (unity),  </span>
<span class="sd">        Inclination (radians), Right ascension of the ascending node (radians),  </span>
<span class="sd">        Argument of the pericenter (radians),  True anomaly (radians) ]`.</span>
<span class="sd">        Units are meters or radians.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The computations do not do special hanling of circular or equatorial</span>
<span class="sd">    orbits. This is possible because atan2(0,0)=0 is defined in numpy, however,</span>
<span class="sd">    some pairs of angles will actually be singular.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    orb2vec, kepler, keplernu, keplerm</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; vec2orb([-5767701.7786, -3097382.0132, 2737195.4374,  3001.4240, -6762.1059, -1280.2560])</span>
<span class="sd">    array([7.12138217e+06, 4.31759805e-03, 4.35789999e-01, 1.60777001e+00,</span>
<span class="sd">           1.39024880e+00, 5.98791190e-01])</span>

<span class="sd">    &gt;&gt;&gt; #              X              Y             Z            Vx          Vy          Vz</span>
<span class="sd">    &gt;&gt;&gt; svec = [[-5767701.7786, -3097382.0132, 2737195.4374,  3001.4240, -6762.1059, -1280.2560],</span>
<span class="sd">    ...         [ -625224.3608, -7162713.9833,   16233.9739, -1131.8951,   116.3879,  7358.7436],</span>
<span class="sd">    ...         [-2301220.9378,  6666917.3737,  968353.5303, -6610.7556, -1833.8971, -2992.6557]]</span>
<span class="sd">    &gt;&gt;&gt; vec2orb(svec)</span>
<span class="sd">    array([[7.12138217e+06, 4.31759805e-03, 4.35789999e-01, 1.60777001e+00,</span>
<span class="sd">            1.39024880e+00, 5.98791190e-01],</span>
<span class="sd">           [7.19093100e+06, 1.80794915e-04, 1.72419000e+00, 4.62567000e+00,</span>
<span class="sd">            7.39124272e-01, 5.54634573e+00],</span>
<span class="sd">           [7.12297382e+06, 1.74770022e-03, 4.36259992e-01, 5.34368001e+00,</span>
<span class="sd">            1.56062623e+00, 1.25322376e+00]])</span>
<span class="sd">    &gt;&gt;&gt; vec2orb(svec).shape</span>
<span class="sd">    (3, 6)</span>

<span class="sd">    &gt;&gt;&gt; vec2orb([svec, svec]).shape</span>
<span class="sd">    (2, 3, 6)</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    
    <span class="c1"># Force input array to ndarray and check the shape</span>

    <span class="n">svec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">svec</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">svec</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span> <span class="p">,</span> <span class="s2">&quot;State vector svec must have six elements in the last dimension.&quot;</span> 

    <span class="c1"># Inner products (rrdot = R.V , r=sqrt(R.R) , vsq = V.V )</span>

    <span class="n">rrdot</span> <span class="o">=</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">vsq</span> <span class="o">=</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>

    <span class="c1"># Angular momentum vector (H = R x V)</span>

    <span class="n">hx</span> <span class="o">=</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">-</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
    <span class="n">hy</span> <span class="o">=</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="n">hz</span> <span class="o">=</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">-</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

    <span class="n">hsini2</span> <span class="o">=</span> <span class="n">hx</span> <span class="o">*</span> <span class="n">hx</span> <span class="o">+</span> <span class="n">hy</span> <span class="o">*</span> <span class="n">hy</span>
    <span class="n">hsq</span> <span class="o">=</span> <span class="n">hsini2</span> <span class="o">+</span> <span class="n">hz</span> <span class="o">*</span> <span class="n">hz</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">hsq</span><span class="p">)</span>

    <span class="c1"># Semi-major axis</span>

    <span class="n">ainv</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">/</span> <span class="n">r</span> <span class="o">-</span> <span class="n">vsq</span> <span class="o">/</span> <span class="n">GM</span>
    <span class="n">a</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">ainv</span>

    <span class="c1"># Eccentricity</span>

    <span class="n">ome2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">hsq</span> <span class="o">*</span> <span class="n">ainv</span> <span class="o">/</span> <span class="n">GM</span><span class="p">)</span>
    <span class="c1">#ecc = np.sqrt(1.0 - ome2)</span>
    <span class="c1">#ecc[ome2 &gt; 1] = 0  # special handling of negative values</span>
    <span class="n">ecc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">ome2</span><span class="p">)</span>
    <span class="n">ecc</span><span class="p">[</span><span class="n">ome2</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">ome2</span><span class="p">[</span><span class="n">ome2</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Inclination (0...pi)</span>

    <span class="n">incl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">hz</span> <span class="o">/</span> <span class="n">h</span><span class="p">)</span>

    <span class="c1"># Determine orbit type (for handling of special cases)</span>
    <span class="c1">#    </span>
    <span class="c1">#   &#39;ei&#39;   elliptical inclined     (all Kepler elements defined)</span>
    <span class="c1">#   &#39;ci&#39;   circular inclined       (w =0, nu=arglat)</span>
    <span class="c1">#   &#39;ee&#39;   elliptical equatorial   (w=lonper, omega=0)</span>
    <span class="c1">#   &#39;ce&#39;   circular equatorial     (w=0, omega=0, nu=truelon)</span>
    
    <span class="c1"># corbtyp = orbtype(ecc, incl, tol=1e-8)</span>

    <span class="c1"># Standard handling of elliptical inclined orbits...</span>

    <span class="c1"># The computations below do not do special hanling of circular or equatorial</span>
    <span class="c1"># orbits. This is possible because atan2(0,0)=0 is defined in Matlab, however,</span>
    <span class="c1"># the some pairs of angles will actually be singular</span>

    <span class="c1"># Longitude of ascending node (0...2*pi)</span>

    <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">hx</span><span class="p">,</span> <span class="o">-</span><span class="n">hy</span><span class="p">))</span>
    <span class="n">omega</span><span class="p">[</span><span class="n">omega</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="c1"># True anomaly (0...2*pi)</span>

    <span class="n">resinf</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">ome2</span> <span class="o">*</span> <span class="n">rrdot</span> <span class="o">/</span> <span class="n">h</span>
    <span class="n">recosf</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">ome2</span> <span class="o">-</span> <span class="n">r</span>
    <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">resinf</span><span class="p">,</span> <span class="n">recosf</span><span class="p">))</span>
    <span class="n">nu</span><span class="p">[</span><span class="n">nu</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="c1"># Argument of perigee (0...2*pi)</span>

    <span class="n">suprod</span> <span class="o">=</span> <span class="o">-</span><span class="n">hz</span> <span class="o">*</span> <span class="p">(</span><span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">hx</span> <span class="o">+</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">hy</span><span class="p">)</span> <span class="o">+</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">hsini2</span>
    <span class="n">cuprod</span> <span class="o">=</span> <span class="n">h</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">hy</span> <span class="o">+</span> <span class="n">svec</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">hx</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">suprod</span> <span class="o">*</span> <span class="n">recosf</span> <span class="o">-</span> <span class="n">cuprod</span> <span class="o">*</span> <span class="n">resinf</span><span class="p">,</span> <span class="n">cuprod</span> <span class="o">*</span> <span class="n">recosf</span> <span class="o">+</span> <span class="n">suprod</span> <span class="o">*</span> <span class="n">resinf</span><span class="p">))</span>
    <span class="n">w</span><span class="p">[</span><span class="n">w</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="c1"># stack the output array</span>

    <span class="c1">#orb = np.array([a, ecc, incl, omega, w, nu])</span>
    <span class="c1">#orb = orb.transpose()</span>
    
    <span class="n">orb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">ecc</span><span class="p">,</span> <span class="n">incl</span><span class="p">,</span> <span class="n">omega</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">nu</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">orb</span></div>



<div class="viewcode-block" id="orb2vec">
<a class="viewcode-back" href="../../reference/generated/pymgp.satorb.orb2vec.html#pymgp.satorb.orb2vec">[docs]</a>
<span class="k">def</span> <span class="nf">orb2vec</span><span class="p">(</span><span class="n">orb</span><span class="p">,</span> <span class="n">GM</span><span class="o">=</span><span class="mf">3986004418e5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert Keplerian elements into intertial state vector.</span>
<span class="sd">    </span>
<span class="sd">    This function converts an array with 6-element Kepler elements into an inertial state </span>
<span class="sd">    vector(s), with cartesian position and velocity `[X, Y, Z, Xdot, Ydot, Zdot]`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    orb : array_like with shape (...,6)</span>
<span class="sd">        Array with the 6 Keplerian elements `[ Semi-major axis (meters), Eccentricity (unity),  </span>
<span class="sd">        Inclination (radians), Right ascension of the ascending node (radians),  </span>
<span class="sd">        Argument of the pericenter (radians),  True anomaly (radians) ]`.</span>
<span class="sd">        Units are meters or radians.</span>
<span class="sd">    GM : float, optional</span>
<span class="sd">        Value of GM. Default for GM [meter**3/sec**2] is the IERS 1996 standard</span>
<span class="sd">        value for the Earth (GM=3986004418e5)</span>
<span class="sd">        </span>
<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    svec : ndarray with shape (...,6) similar to `orb`</span>
<span class="sd">        Array with  6-element inertial state vector `svec` with Cartesian  </span>
<span class="sd">        position and velocity `[X, Y, Z, Xdot, Ydot, Zdot]` in an ECI frame.</span>
<span class="sd">        Units are meter and meter/sec</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    vec2orb, kepler, keplernu, keplerm</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; orb2vec([7121382.201, 0.0043176, 0.43579, 1.60777, 1.39025, 0.59879])</span>
<span class="sd">    array([-5.76770178e+06, -3.09738201e+06,  2.73719544e+06,  3.00142402e+03,</span>
<span class="sd">           -6.76210591e+03, -1.28025603e+03])</span>

<span class="sd">    &gt;&gt;&gt; #             a          ecc      inc      raan      argp     nu </span>
<span class="sd">    &gt;&gt;&gt; orb = [ [7121382.201, 0.0043176, 0.43579, 1.60777, 1.39025, 0.59879],</span>
<span class="sd">    ...         [7190931.091, 0.0001808, 1.72419, 4.62567, 0.73905, 5.54642],</span>
<span class="sd">    ...         [7122973.745, 0.0017477, 0.43626, 5.34368, 1.56062, 1.25323] ]</span>
<span class="sd">    &gt;&gt;&gt; orb2vec(orb)</span>
<span class="sd">    array([[-5.76770178e+06, -3.09738201e+06,  2.73719544e+06,</span>
<span class="sd">             3.00142402e+03, -6.76210591e+03, -1.28025603e+03],</span>
<span class="sd">           [-6.25224361e+05, -7.16271398e+06,  1.62339739e+04,</span>
<span class="sd">            -1.13189511e+03,  1.16387852e+02,  7.35874365e+03],</span>
<span class="sd">           [-2.30122094e+06,  6.66691737e+06,  9.68353530e+05,</span>
<span class="sd">            -6.61075555e+03, -1.83389705e+03, -2.99265574e+03]])</span>
<span class="sd">    &gt;&gt;&gt; orb2vec(orb).shape</span>
<span class="sd">    (3, 6)</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; orb2vec([orb, orb]).shape</span>
<span class="sd">    (2, 3, 6)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span> 
    
    <span class="c1"># Force input array to ndarray and check the shape</span>

    <span class="n">orb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">orb</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span> <span class="p">,</span> <span class="s2">&quot;Array with Keplerian elements must have six elements in the last dimension.&quot;</span> 

    <span class="c1"># Compute position (rx,ry) and velocity (vx,vy) in orbital plane (perifocal system)</span>

    <span class="n">ecc</span> <span class="o">=</span> <span class="n">orb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>                   <span class="c1"># Eccentricity</span>
    <span class="n">cosnu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">orb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>         <span class="c1"># Cosine and sine of true anomaly (nu)</span>
    <span class="n">sinnu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">orb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">orb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">ecc</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Parameter of the ellipse p=a*(1-e^2)</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">ecc</span> <span class="o">*</span> <span class="n">cosnu</span><span class="p">)</span>         <span class="c1"># Length of position vector</span>

    <span class="n">rx</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">cosnu</span>                      <span class="c1"># Position (rx,ry) in orbital plane</span>
    <span class="n">ry</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">sinnu</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="n">p</span><span class="p">[</span><span class="nb">abs</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0001</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0001</span>         <span class="c1"># Protect against division by zero</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">GM</span> <span class="o">/</span> <span class="n">p</span><span class="p">)</span>

    <span class="n">vx</span> <span class="o">=</span> <span class="o">-</span><span class="n">tmp</span> <span class="o">*</span> <span class="n">sinnu</span>                   <span class="c1"># Velocity (vx,vy) in orbital plane</span>
    <span class="n">vy</span> <span class="o">=</span> <span class="n">tmp</span> <span class="o">*</span> <span class="p">(</span><span class="n">ecc</span> <span class="o">+</span> <span class="n">cosnu</span><span class="p">)</span>

    <span class="c1"># Convert into inertial frame (3-1-3 Euler rotations)</span>

    <span class="n">cosincl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">orb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>       <span class="c1"># Cosine and sine of inclination (incl)</span>
    <span class="n">sinincl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">orb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">cosomega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">orb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>      <span class="c1"># Cosine and sine of longitude of ascending node (omega)</span>
    <span class="n">sinomega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">orb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
    <span class="n">cosw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">orb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>          <span class="c1"># Cosine and sine of argument of perigee (w)</span>
    <span class="n">sinw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">orb</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>

    <span class="n">rx0</span> <span class="o">=</span> <span class="n">cosw</span> <span class="o">*</span> <span class="n">rx</span> <span class="o">-</span> <span class="n">sinw</span> <span class="o">*</span> <span class="n">ry</span>         <span class="c1"># Cosine and sine of argument of latitude u=w+nu</span>
    <span class="n">ry0</span> <span class="o">=</span> <span class="n">cosw</span> <span class="o">*</span> <span class="n">ry</span> <span class="o">+</span> <span class="n">sinw</span> <span class="o">*</span> <span class="n">rx</span>

    <span class="n">vx0</span> <span class="o">=</span> <span class="n">cosw</span> <span class="o">*</span> <span class="n">vx</span> <span class="o">-</span> <span class="n">sinw</span> <span class="o">*</span> <span class="n">vy</span>
    <span class="n">vy0</span> <span class="o">=</span> <span class="n">cosw</span> <span class="o">*</span> <span class="n">vy</span> <span class="o">+</span> <span class="n">sinw</span> <span class="o">*</span> <span class="n">vx</span>

    <span class="c1"># stack the output array</span>

    <span class="n">svec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">rx0</span> <span class="o">*</span> <span class="n">cosomega</span> <span class="o">-</span> <span class="n">ry0</span> <span class="o">*</span> <span class="n">cosincl</span> <span class="o">*</span> <span class="n">sinomega</span><span class="p">,</span>
                     <span class="n">rx0</span> <span class="o">*</span> <span class="n">sinomega</span> <span class="o">+</span> <span class="n">ry0</span> <span class="o">*</span> <span class="n">cosincl</span> <span class="o">*</span> <span class="n">cosomega</span><span class="p">,</span>
                     <span class="n">ry0</span> <span class="o">*</span> <span class="n">sinincl</span><span class="p">,</span>
                     <span class="n">vx0</span> <span class="o">*</span> <span class="n">cosomega</span> <span class="o">-</span> <span class="n">vy0</span> <span class="o">*</span> <span class="n">cosincl</span> <span class="o">*</span> <span class="n">sinomega</span><span class="p">,</span>
                     <span class="n">vx0</span> <span class="o">*</span> <span class="n">sinomega</span> <span class="o">+</span> <span class="n">vy0</span> <span class="o">*</span> <span class="n">cosincl</span> <span class="o">*</span> <span class="n">cosomega</span><span class="p">,</span>
                     <span class="n">vy0</span> <span class="o">*</span> <span class="n">sinincl</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">svec</span></div>


<div class="viewcode-block" id="orbtype">
<a class="viewcode-back" href="../../reference/generated/pymgp.satorb.orbtype.html#pymgp.satorb.orbtype">[docs]</a>
<span class="k">def</span> <span class="nf">orbtype</span><span class="p">(</span><span class="n">ecc</span><span class="p">,</span> <span class="n">incl</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine circular and equatorial orbit types (for handling of special cases).</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ecc, incl : array_like </span>
<span class="sd">        Eccentricity (unity) and inclination (radians)</span>
<span class="sd">    tol : float, default 1e-8</span>
<span class="sd">        Tolerance for zero eccentricity and zero inclination</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    corbtype : ndarray of {&#39;ei&#39;, &#39;ci&#39;, &#39;ee&#39;, &#39;ce&#39;}</span>
<span class="sd">        Array with two character codes for the orbit type:    </span>
<span class="sd">        </span>
<span class="sd">        | &#39;ei&#39; -&gt;  elliptical inclined     (all Kepler elements defined)</span>
<span class="sd">        | &#39;ci&#39; -&gt;  circular inclined       (w =0, nu=arglat)</span>
<span class="sd">        | &#39;ee&#39; -&gt;  elliptical equatorial   (w=lonper, omega=0)</span>
<span class="sd">        | &#39;ce&#39; -&gt;  circular equatorial     (w=0, omega=0, nu=truelon)</span>
<span class="sd">        </span>
<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Nearly circular and/or equatiorial orbits are often in need of special handling </span>
<span class="sd">    because of singularities between pairs of orbital elements. </span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    vec2orb, orb2vec</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; #             a          ecc      inc      raan      argp     nu </span>
<span class="sd">    &gt;&gt;&gt; orb = [ [7121382.201, 0.0043176, 0.43579, 1.60777, 1.39025, 0.59879],</span>
<span class="sd">    ...         [7190931.091, 0.1e-9,    1.72419, 4.62567, 0.73905, 5.54642],</span>
<span class="sd">    ...         [7122973.745, 0.0017477, 0.1e-9,  5.34368, 1.56062, 1.25323] ]</span>
<span class="sd">    &gt;&gt;&gt; orb = np.asarray(orb)</span>
<span class="sd">    &gt;&gt;&gt; orbtype(orb[...,1],orb[...,2])</span>
<span class="sd">    array([b&#39;ei&#39;, b&#39;ci&#39;, b&#39;ee&#39;], dtype=&#39;|S2&#39;)</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>    
    
    <span class="n">ecc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ecc</span><span class="p">)</span>
    <span class="n">incl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">incl</span><span class="p">)</span>

    <span class="c1"># Determine orbit type (for handling of special cases)</span>
  
    <span class="n">idxecc</span> <span class="o">=</span> <span class="n">ecc</span> <span class="o">&lt;</span> <span class="n">tol</span>
    <span class="n">idxincl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">((</span><span class="n">incl</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">),</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">incl</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">tol</span><span class="p">))</span>

    <span class="c1"># Return array with character codes</span>

    <span class="n">corbtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ecc</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;S2&#39;</span><span class="p">)</span>
    <span class="n">corbtype</span><span class="p">[</span> <span class="n">idxecc</span> <span class="o">&amp;</span> <span class="n">idxincl</span> <span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;ce&#39;</span>      <span class="c1"># circular equatorial =&gt; w=0, omega=0, nu=truelon</span>
    <span class="n">corbtype</span><span class="p">[</span> <span class="n">idxecc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">idxincl</span> <span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;ci&#39;</span>     <span class="c1"># circular inclined =&gt; w =0, nu=arglat</span>
    <span class="n">corbtype</span><span class="p">[</span> <span class="o">~</span><span class="n">idxecc</span> <span class="o">&amp;</span> <span class="n">idxincl</span> <span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;ee&#39;</span><span class="p">;</span>    <span class="c1"># elliptical equatorial =&gt; w=lonper, omega=0</span>
    <span class="n">corbtype</span><span class="p">[</span> <span class="o">~</span><span class="n">idxecc</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">idxincl</span> <span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;ei&#39;</span>    <span class="c1"># elliptical inclined</span>

    <span class="k">return</span> <span class="n">corbtype</span></div>


<div class="viewcode-block" id="kepler">
<a class="viewcode-back" href="../../reference/generated/pymgp.satorb.kepler.html#pymgp.satorb.kepler">[docs]</a>
<span class="k">def</span> <span class="nf">kepler</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">ecc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute mean anomaly from eccentric anomaly (Kepler&#39;s equation).</span>
<span class="sd">        </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    E : array_like</span>
<span class="sd">        Eccentric anomaly (radians)</span>
<span class="sd">    ecc : array_like </span>
<span class="sd">        Eccentricity (unity)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    M : array_like</span>
<span class="sd">        Mean anomaly (radians)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This routine should only be used for elliptical orbits. Parabolic and</span>
<span class="sd">    hyperbolic orbits are not supported and give false results (this is</span>
<span class="sd">    nowhere checked for).</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    keplernu, keplerm</span>
<span class="sd">    &quot;&quot;&quot;</span>    

    <span class="n">M</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">ecc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">M</span></div>



<div class="viewcode-block" id="keplernu">
<a class="viewcode-back" href="../../reference/generated/pymgp.satorb.keplernu.html#pymgp.satorb.keplernu">[docs]</a>
<span class="k">def</span> <span class="nf">keplernu</span><span class="p">(</span><span class="n">nu</span><span class="p">,</span> <span class="n">ecc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute mean and eccentric anomaly from true anomaly (Kepler&#39;s equation).</span>
<span class="sd">        </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nu : array_like</span>
<span class="sd">        True anomaly (radians)</span>
<span class="sd">    ecc : array_like </span>
<span class="sd">        Eccentricity (unity)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    M : array_like</span>
<span class="sd">        Mean anomaly (radians)</span>
<span class="sd">    E : array_like</span>
<span class="sd">        Eccentric anomaly (radians) </span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This routine should only be used for elliptical orbits. Parabolic and</span>
<span class="sd">    hyperbolic orbits are not supported and give false results (this is</span>
<span class="sd">    nowhere checked for).</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    kepler, keplerm</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">denom</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">ecc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">nu</span><span class="p">)</span>
    <span class="n">sine</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">ecc</span> <span class="o">*</span> <span class="n">ecc</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">nu</span><span class="p">))</span> <span class="o">/</span> <span class="n">denom</span>
    <span class="n">cose</span> <span class="o">=</span> <span class="p">(</span><span class="n">ecc</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">nu</span><span class="p">))</span> <span class="o">/</span> <span class="n">denom</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">sine</span><span class="p">,</span> <span class="n">cose</span><span class="p">)</span>

    <span class="c1"># Compute mean anomaly</span>

    <span class="n">M</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">ecc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">M</span><span class="p">,</span> <span class="n">E</span></div>



<div class="viewcode-block" id="keplerm">
<a class="viewcode-back" href="../../reference/generated/pymgp.satorb.keplerm.html#pymgp.satorb.keplerm">[docs]</a>
<span class="k">def</span> <span class="nf">keplerm</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">ecc</span><span class="p">,</span> <span class="n">TOL</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute eccentric and true anomaly from mean anomaly solving Kepler&#39;s eqn.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : array_like</span>
<span class="sd">        Mean anomaly (radians)</span>
<span class="sd">    ecc : array_like </span>
<span class="sd">        Eccentricity (unity)</span>
<span class="sd">    tol : float, default 1e-10</span>
<span class="sd">        Stop criterion for iterations</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    E : array_like</span>
<span class="sd">        Eccentric anomaly (radians) </span>
<span class="sd">    nu : array_like</span>
<span class="sd">        True anomaly (radians)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Kepler&#39;s equation ``M=E-ecc*sin(E)`` is solved iteratively using Newton&#39;s</span>
<span class="sd">    method. </span>
<span class="sd">    </span>
<span class="sd">    This routine should only be used for elliptical orbits. Parabolic and</span>
<span class="sd">    hyperbolic orbits are not supported and give false results (this is</span>
<span class="sd">    nowhere checked for).</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    kepler, keplernu</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">E</span> <span class="o">=</span> <span class="n">M</span>                            <span class="c1"># Use M for the first value of E</span>
    <span class="c1"># [m, n] = E.shape</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">E</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>              <span class="c1"># Newton&#39;s method for root finding</span>
    <span class="k">while</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">TOL</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">M</span> <span class="o">-</span> <span class="n">E</span> <span class="o">+</span> <span class="n">ecc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>  <span class="c1"># Kepler&#39;s Equation</span>
        <span class="n">fdot</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">+</span> <span class="n">ecc</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>  <span class="c1"># Derivative of Kepler&#39;s equation</span>
        <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">-</span> <span class="n">f</span> <span class="o">/</span> <span class="n">fdot</span>

    <span class="n">sinnu</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ecc</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">E</span><span class="p">)</span> <span class="o">/</span> <span class="n">fdot</span>
    <span class="n">cosnu</span> <span class="o">=</span> <span class="p">(</span><span class="n">ecc</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">E</span><span class="p">))</span> <span class="o">/</span> <span class="n">fdot</span>

    <span class="n">nu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">sinnu</span><span class="p">,</span> <span class="n">cosnu</span><span class="p">)</span>    <span class="c1"># True anomaly</span>

    <span class="k">return</span> <span class="n">E</span><span class="p">,</span> <span class="n">nu</span></div>



<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#                 UT1 to GMST, and ECI/ECEF, conversions</span>
<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1">#   ut2gmst    - Compute Greenwich Mean Siderial Time from UT1</span>
<span class="c1">#   ecef2eci   - Convert position and velocity from ECEF to ECI reference frame</span>
<span class="c1">#   eci2ecef   - Convert position and velocity from ECI to ECEF reference frame</span>

<div class="viewcode-block" id="ut2gmst">
<a class="viewcode-back" href="../../reference/generated/pymgp.satorb.ut2gmst.html#pymgp.satorb.ut2gmst">[docs]</a>
<span class="k">def</span> <span class="nf">ut2gmst</span><span class="p">(</span><span class="n">ut1</span><span class="p">,</span> <span class="n">model</span><span class="o">=</span><span class="s2">&quot;IAU-82&quot;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute Greenwich Mean Siderial Time from UT1.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ut1 : array_like, float64 or datetime64 or str</span>
<span class="sd">        Universal time datetime64 object, numpy parsable datetime string, or</span>
<span class="sd">        matplotlib sequential datenumber (days since &#39;01-Jan-1970&#39;)</span>
<span class="sd">    model : {&#39;IAU-82&#39;, &#39;APPROXIMATE&#39;}, optional</span>
<span class="sd">        Model for `ut` to `gmst` conversion. Default is &#39;IAU-82&#39; model.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    gmst : array_like</span>
<span class="sd">        Greenwich Mean Siderial Time GMST [0-2pi rad] for UT1 (radians)</span>
<span class="sd">    omegae : float</span>
<span class="sd">        Rotation rate of the Earth (rev/day)</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ecef2eci, eci2ecef</span>
<span class="sd">    </span>
<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ut2gmst(&#39;2012-01-04 00:00&#39;)</span>
<span class="sd">    (1.7979884328663978, 1.0027379093)</span>

<span class="sd">    &gt;&gt;&gt; ut2gmst([&#39;2012-01-04 15:00:03.13&#39;, &#39;2012-01-04 16:00:03&#39;])</span>
<span class="sd">    (array([5.73595924, 5.99846593]), 1.0027379093)</span>

<span class="sd">    Use matplotlib datenumbers as input (days since 1-jan-1970)</span>

<span class="sd">    &gt;&gt;&gt; datenum = np.datetime64(&#39;2012-01-04 15:00:03.13&#39;,&#39;ns&#39;).astype(np.int64)*1e-9/86400</span>
<span class="sd">    &gt;&gt;&gt; print(datenum)</span>
<span class="sd">    15343.625036226851</span>
<span class="sd">    &gt;&gt;&gt; ut2gmst(datenum)</span>
<span class="sd">    (5.7359592379770525, 1.0027379093)</span>

<span class="sd">    &gt;&gt;&gt; ut2gmst(np.arange(datenum,datenum+1,.1))</span>
<span class="sd">    (array([5.73595924, 0.08281274, 0.71285155, 1.34289036, 1.97292917,</span>
<span class="sd">           2.60296798, 3.23300679, 3.8630456 , 4.49308441, 5.12312322]), 1.0027379093)</span>
<span class="sd">    &gt;&gt;&gt; gmst0, omegae = ut2gmst(datenum)</span>
<span class="sd">    &gt;&gt;&gt; gmst = (gmst0 + 2*np.pi*omegae*np.arange(0,1,.1) ) % ( 2*np.pi ) </span>
<span class="sd">    &gt;&gt;&gt; gmst</span>
<span class="sd">    array([5.73595924, 0.08281274, 0.71285155, 1.34289036, 1.97292917,</span>
<span class="sd">           2.60296798, 3.23300679, 3.8630456 , 4.49308441, 5.12312322])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">assert</span>  <span class="n">model</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;IAU-82&#39;</span><span class="p">,</span> <span class="s1">&#39;APPROXIMATE&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported model </span><span class="si">{</span><span class="n">model</span><span class="si">}</span><span class="s2">.&quot;</span>

    <span class="c1"># force input to be numpy array</span>

    <span class="n">ut1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ut1</span><span class="p">)</span>

    <span class="c1"># convert `ut1` to `dut` (np.float64) with days since 2000-01-01 12:00</span>

    <span class="k">if</span> <span class="n">ut1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
        <span class="c1"># ut1 is matplotlib sequential datenumber (days since 01-Jan-1970)</span>
        <span class="c1"># ( np.datetime64(&#39;2000-01-01T12:00:00&#39;) - np.datetime64(&#39;1970-01-01&#39;) ) / np.timedelta64(1, &#39;D&#39;) -&gt; 10957.5</span>
        <span class="n">dut1</span> <span class="o">=</span> <span class="n">ut1</span> <span class="o">-</span> <span class="mf">10957.5</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># ut1 is datetime64 object or a parsable ISO string by datetime64</span>
        <span class="n">t0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;2000-01-01T12:00:00&#39;</span><span class="p">,</span><span class="s1">&#39;ns&#39;</span><span class="p">)</span>
        <span class="n">dut1</span> <span class="o">=</span> <span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span> <span class="n">ut1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;datetime64[ns]&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="n">t0</span> <span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span>

    <span class="c1"># gmst in seconds</span>

    <span class="k">if</span> <span class="n">model</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;APPROXIMATE&quot;</span><span class="p">:</span>
        <span class="n">gmst</span> <span class="o">=</span> <span class="p">(</span><span class="mf">18.697374558</span> <span class="o">+</span> <span class="mf">24.06570982441908</span> <span class="o">*</span> <span class="n">dut1</span> <span class="p">)</span> <span class="o">%</span> <span class="mi">24</span>
        <span class="n">gmst</span> <span class="o">*=</span> <span class="mi">3600</span>
    <span class="k">elif</span> <span class="n">model</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;IAU-82&quot;</span><span class="p">:</span>
        <span class="n">j2000</span> <span class="o">=</span> <span class="n">dut1</span> <span class="o">/</span> <span class="mf">36525.0</span>
        <span class="n">gmst</span> <span class="o">=</span> <span class="p">((</span><span class="o">-</span> <span class="mf">6.2e-6</span> <span class="o">*</span> <span class="n">j2000</span> <span class="o">+</span> <span class="mf">0.093104</span><span class="p">)</span> <span class="o">*</span> <span class="n">j2000</span> <span class="o">+</span> <span class="p">(</span><span class="mf">876600.0</span> <span class="o">*</span> <span class="mf">3600.0</span> <span class="o">+</span> <span class="mf">8640184.812866</span><span class="p">))</span> <span class="o">*</span> <span class="n">j2000</span> <span class="o">+</span> <span class="mf">67310.54841</span>
        <span class="n">gmst</span> <span class="o">%=</span> <span class="mi">86400</span>

    <span class="c1"># output gmst in radians and omegae in revs/day    </span>

    <span class="n">gmst</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mi">43200</span>
    <span class="n">omegae</span> <span class="o">=</span> <span class="mf">1.0027379093</span>

    <span class="k">return</span> <span class="n">gmst</span><span class="p">,</span> <span class="n">omegae</span></div>


<div class="viewcode-block" id="ecef2eci">
<a class="viewcode-back" href="../../reference/generated/pymgp.satorb.ecef2eci.html#pymgp.satorb.ecef2eci">[docs]</a>
<span class="k">def</span> <span class="nf">ecef2eci</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">xsate</span><span class="p">,</span> <span class="n">vsate</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert position and velocity from ECEF to ECI reference frame.</span>
<span class="sd">    </span>
<span class="sd">    Convert position and velocity given in an Earth Centered Earth Fixed (ECEF) </span>
<span class="sd">    reference frame into a non-rotating pseudo-inertial Earth Centered Inertial (ECI) </span>
<span class="sd">    reference frame.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t : array_like with shape (n,) or scalar, of type datetime64, str or float</span>
<span class="sd">        Universal time as `datetime64` object, ISO date string or sequential date </span>
<span class="sd">        number (days since 1970-01-01).</span>
<span class="sd">    xsate : array_like with shape (...,n,3) or (...,n,6), or, shape (3,) or (6,) </span>
<span class="sd">        Array with Cartesian coordinates (m) or state vector with positions (m) </span>
<span class="sd">        and velocities (m/s) in an ECEF reference frame .</span>
<span class="sd">    vsate : array_like with shape (...,n,3), optional</span>
<span class="sd">        Array with velocities in ECEF reference frame (m/s). If empty, velocities</span>
<span class="sd">        are taken from &#39;xsate[...,3:6]&#39;, or if `xsate` has shape (...,n,3) or (3,)</span>
<span class="sd">        velocities are assumed to be zero (e.g. non-moving points on the Earth surface)  </span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xsat : ndarray with shape (...,n,3) or shape (...,n,6) </span>
<span class="sd">        Array with Cartesian coordinates (m) or state vector with positions (m) </span>
<span class="sd">        and velocities (m/s) in ECI reference frame. </span>
<span class="sd">    vsat : ndarray with shape (...,n,3), optional</span>
<span class="sd">        Array with velocities in ECI reference frame (m/s), only if `xsat` is not</span>
<span class="sd">        a state vector.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----    </span>
<span class="sd">    The function returns a single ndarray `xsat` with the ECI state vector when the </span>
<span class="sd">    parameter `xsate` is a state vector (having 6 elements). Otherwise, it returns </span>
<span class="sd">    two ndarrays.</span>
<span class="sd">    </span>
<span class="sd">    If the parameter `xsate` has shape (3,) or (...,1,3), and parameter `t` has shape</span>
<span class="sd">    (n,) with &#39;n &gt; 1&#39;, then `xsate` is extended to match the length of `t`.</span>
<span class="sd">    </span>
<span class="sd">    The function always returns ndarrays with at least two dimensions.</span>
<span class="sd">    </span>
<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ut2gmst, eci2ecef</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Example with single statevector (note the two dimensional result(s)) </span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; ecef2eci(&#39;2012-01-04 15:00:00&#39;,[ -3312531.1007, -5646883.8176, 2737195.4374,  5670.7751, -3969.9994, -1280.2560 ])</span>
<span class="sd">    array([[-5.76770178e+06, -3.09738201e+06,  2.73719544e+06,</span>
<span class="sd">             3.00142403e+03, -6.76210591e+03, -1.28025600e+03]])</span>
<span class="sd">    &gt;&gt;&gt; ecef2eci(&#39;2012-01-04 15:00:00&#39;,[ -3312531.1007, -5646883.8176, 2737195.4374], [ 5670.7751, -3969.9994, -1280.2560 ])</span>
<span class="sd">    (array([[-5767701.77861271, -3097382.01317908,  2737195.4374    ]]), array([[ 3001.4240322 , -6762.10590869, -1280.256     ]]))</span>

<span class="sd">    Two dimensional examples </span>

<span class="sd">    &gt;&gt;&gt; t = np.array([&#39;2012-01-04 15:00:00&#39;, &#39;2012-01-04 16:00:00&#39;, &#39;2012-01-04 17:00:00&#39;, &#39;2012-01-04 18:00:00&#39;], dtype=&#39;datetime64[ns]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; svece = [[-3312531.1007, -5646883.8176, 2737195.4374,  5670.7751, -3969.9994, -1280.2560 ],</span>
<span class="sd">    ...          [ 1413410.4872, -7049655.8712,   16233.9739, -1633.0415,  -309.5460,  7358.7436 ],</span>
<span class="sd">    ...          [-2450115.4006,  6613647.9795,  968353.5303, -6085.7029, -1802.9846, -2992.6557 ],</span>
<span class="sd">    ...          [ -649857.9621,  7022897.5289,  968353.5303, -6345.1020,  -161.9056, -2992.6557 ]]</span>
<span class="sd">    &gt;&gt;&gt; ecef2eci(t, svece)</span>
<span class="sd">    array([[-5.76770178e+06, -3.09738201e+06,  2.73719544e+06,</span>
<span class="sd">             3.00142403e+03, -6.76210591e+03, -1.28025600e+03],</span>
<span class="sd">           [-6.25224361e+05, -7.16271398e+06,  1.62339739e+04,</span>
<span class="sd">            -1.13189509e+03,  1.16387949e+02,  7.35874360e+03],</span>
<span class="sd">           [-2.30122094e+06,  6.66691737e+06,  9.68353530e+05,</span>
<span class="sd">            -6.61075561e+03, -1.83389708e+03, -2.99265570e+03],</span>
<span class="sd">           [-2.30122094e+06,  6.66691737e+06,  9.68353530e+05,</span>
<span class="sd">            -6.61075556e+03, -1.83389711e+03, -2.99265570e+03]])</span>

<span class="sd">    &gt;&gt;&gt; svece_array = np.asarray(svece)</span>
<span class="sd">    &gt;&gt;&gt; xsate = svece_array[:,0:3]</span>
<span class="sd">    &gt;&gt;&gt; vsate = svece_array[:,3:]</span>
<span class="sd">    &gt;&gt;&gt; ecef2eci(t, xsate, vsate)</span>
<span class="sd">    (array([[-5767701.77861271, -3097382.01317908,  2737195.4374    ],</span>
<span class="sd">           [ -625224.36062227, -7162713.98329963,    16233.9739    ],</span>
<span class="sd">           [-2301220.9380175 ,  6666917.37367665,   968353.5303    ],</span>
<span class="sd">           [-2301220.93814086,  6666917.37358403,   968353.5303    ]]), array([[ 3001.4240322 , -6762.10590869, -1280.256     ],</span>
<span class="sd">           [-1131.89509013,   116.38794901,  7358.7436    ],</span>
<span class="sd">           [-6610.7556061 , -1833.89707562, -2992.6557    ],</span>
<span class="sd">           [-6610.75556101, -1833.89710895, -2992.6557    ]]))</span>

<span class="sd">    Check that inverse operation returns the original</span>

<span class="sd">    &gt;&gt;&gt; svec = ecef2eci(t, svece)</span>
<span class="sd">    &gt;&gt;&gt; svece2 = eci2ecef(t,svec)</span>
<span class="sd">    &gt;&gt;&gt; print(np.max(np.abs(svece2-svece)) &lt; 1e-8)</span>
<span class="sd">    True</span>

<span class="sd">    Example with more than two dimensions</span>

<span class="sd">    &gt;&gt;&gt; svec = ecef2eci(t, svece)</span>
<span class="sd">    &gt;&gt;&gt; svec23 = ecef2eci(t,[[svece, svece, svece],[svece, svece, svece]])</span>
<span class="sd">    &gt;&gt;&gt; svec23.shape</span>
<span class="sd">    (2, 3, 4, 6)</span>
<span class="sd">    &gt;&gt;&gt; np.max(np.abs(svec23 - svec), axis=(-1,-2))</span>
<span class="sd">    array([[0., 0., 0.],</span>
<span class="sd">           [0., 0., 0.]])</span>

<span class="sd">    Special case, point on the Earth surface (Delft), ECEF velocity is assumed to be zero</span>

<span class="sd">    &gt;&gt;&gt; xDelftECI, vDelftECI= ecef2eci(&#39;2012-01-04 15:00:00&#39;,[ 3924687.7018, 301132.7660, 5001910.7746])</span>
<span class="sd">    &gt;&gt;&gt; print(xDelftECI, vDelftECI)</span>
<span class="sd">    [[ 3507848.04809349 -1785736.98256649  5001910.7746    ]] [[130.21800963 255.79634368   0.        ]]</span>

<span class="sd">    Check that the inverse transformation returns the original result</span>

<span class="sd">    &gt;&gt;&gt; eci2ecef(&#39;2012-01-04 15:00:00&#39;, xDelftECI, vDelftECI)</span>
<span class="sd">    (array([[3924687.7018,  301132.766 , 5001910.7746]]), array([[0., 0., 0.]]))</span>

<span class="sd">    If ECI velocity is not specified in the inverse operation, &#39;nan&#39; is returned for the ECEF velocity.</span>
<span class="sd">    This is intentional, as there is no sensible default for velocites in an ECI.</span>

<span class="sd">    &gt;&gt;&gt; eci2ecef(&#39;2012-01-04 15:00:00&#39;, xDelftECI)</span>
<span class="sd">    (array([[3924687.7018,  301132.766 , 5001910.7746]]), array([[nan, nan, nan]]))</span>

<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># Convert input parameters to all numpy arrays</span>
    
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">xsate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">xsate</span><span class="p">)</span>
    <span class="n">vsate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">vsate</span><span class="p">)</span>
    
    <span class="c1"># Check input arguments</span>
   
    <span class="k">assert</span> <span class="n">xsate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">xsate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span> <span class="p">,</span> <span class="s2">&quot;xsate must have shape (...,3) or (...,6).&quot;</span>
    <span class="k">assert</span> <span class="n">xsate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">xsate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Second to last dimension of xsate must be one or match the length of array t.&quot;</span>
    <span class="k">if</span> <span class="n">xsate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
         <span class="k">assert</span> <span class="n">vsate</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;xsate has shape (...,6) and contains also velocities, but then vsate must not be used.&quot;</span>
         <span class="n">vsate</span> <span class="o">=</span> <span class="n">xsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">vsate</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">vsate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">xsate</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">assert</span> <span class="n">vsate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;vsate must have shape (...,3).&quot;</span>
    <span class="k">assert</span> <span class="n">vsate</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">xsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;xsate and vsate must have same shape.&quot;</span>

    <span class="c1"># extend xsate and vsate to match size of t  (HM: CHECK IF THIS WORKS WITH MORE THAN 2 DIMENSIONS)</span>
    
    <span class="k">if</span> <span class="n">xsate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">xsate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">xsate</span><span class="p">,[</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">vsate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">vsate</span><span class="p">,[</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Compute rotation angle (GMST) around Z-axis</span>
   
    <span class="n">gst</span><span class="p">,</span> <span class="n">omegae</span> <span class="o">=</span> <span class="n">ut2gmst</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">gst</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">gst</span>

    <span class="c1"># Rotate satellite positions around z-axis (ECEF -&gt; ECI)</span>

    <span class="n">xsat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">xsate</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span><span class="o">*</span><span class="n">xsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span> <span class="o">*</span> <span class="n">xsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span> <span class="o">*</span> <span class="n">xsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span> <span class="o">*</span> <span class="n">xsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To convert the velocity is more complicated. The velocity in ECEF</span>
<span class="sd">    consists of two parts. We find this by differentiating the transformation</span>
<span class="sd">    formula for the positions</span>
<span class="sd"> </span>
<span class="sd">       xsat = R * xsate</span>

<span class="sd">    This gives (product rule, and some rewriting), with `_dot` the derivatives</span>

<span class="sd">       xsat_dot = R * xsate_dot + R_dot * xsate    &lt;=&gt;</span>
<span class="sd">       vsat = R * ( vsate + inv(R)*R_dot * xsate ) &lt;=&gt;</span>
<span class="sd">       vsat = R * ( vsate + W * xsate )</span>
<span class="sd"> </span>
<span class="sd">    with &#39;W = inv(R)*R_dot = [[ 0, -w[2] w[1]],[ w[2] 0 -w[0]],[-w[1] w[0] 0]]&#39; </span>
<span class="sd">    and with &#39;w&#39; the angular velocity vector of the ECI frame with respect to</span>
<span class="sd">    the ECEF frame, expressed in the ECEF frame. </span>
<span class="sd">    </span>
<span class="sd">    For the ECEF to ECI transformation the angular velocity vector is w = [0, 0, w0]&#39;</span>
<span class="sd">    with &#39;w0=2*np.pi*omegae/86400&#39;, thus &#39;W = [[0, -w0, 0], [w0, 0, 0], [0, 0, 0]]&#39;, </span>
<span class="sd">    hence &#39;W * xsate = [ -w0*xsate[1], w0*xsate[0], 0 ]&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
 
    <span class="c1"># The velocity vector in the ECI is computed as follows</span>

    <span class="n">w0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">omegae</span><span class="o">/</span><span class="mi">86400</span>
    <span class="n">h0</span> <span class="o">=</span> <span class="n">vsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">w0</span> <span class="o">*</span> <span class="n">xsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>   
    <span class="n">h1</span> <span class="o">=</span> <span class="n">vsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">w0</span> <span class="o">*</span> <span class="n">xsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> 
    
    <span class="n">vsat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vsate</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">vsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span> <span class="o">*</span> <span class="n">h0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span> <span class="o">*</span> <span class="n">h1</span>
    <span class="n">vsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span> <span class="o">*</span> <span class="n">h0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span> <span class="o">*</span> <span class="n">h1</span>
    <span class="n">vsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">xsat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="n">vsat</span>
        <span class="k">return</span> <span class="n">xsat</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xsat</span><span class="p">,</span> <span class="n">vsat</span></div>


<div class="viewcode-block" id="eci2ecef">
<a class="viewcode-back" href="../../reference/generated/pymgp.satorb.eci2ecef.html#pymgp.satorb.eci2ecef">[docs]</a>
<span class="k">def</span> <span class="nf">eci2ecef</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">xsat</span><span class="p">,</span> <span class="n">vsat</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert position and velocity from ECI to ECEF reference frame.</span>
<span class="sd">    </span>
<span class="sd">    Convert position and velocity given in a non-rotating pseudo-inertial </span>
<span class="sd">    Earth Centered Inertial (ECI) reference frame into an Earth Centered Earth </span>
<span class="sd">    Fixed (ECEF) reference frame.</span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t : array_like with shape (n,) or scalar, of type datetime64, str or float</span>
<span class="sd">        Universal time as `datetime64` object, ISO date string or sequential date </span>
<span class="sd">        number (days since 1970-01-01).</span>
<span class="sd">    xsat : array_like with shape (...,n,3) or (...,n,6) </span>
<span class="sd">        Array with Cartesian coordinates (m) or state vector with positions (m) </span>
<span class="sd">        and velocities (m/s) in an ECI reference frame .</span>
<span class="sd">    vsat : array_like with shape (...,n,3), optional</span>
<span class="sd">        Array with velocities in ECI reference frame (m/s). If empty, velocities</span>
<span class="sd">        are assumed to be part of the state vector &#39;xsat[...,3:6]&#39;, or if `xsat` </span>
<span class="sd">        has shape (...,3), ``xsate = eci2ecef(t, xsat)`` only returns the positions.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    xsate : ndarray with shape (...,n,3) or shape (...,n,6)</span>
<span class="sd">        Array with Cartesian coordinates (m) or state vector with positions (m) </span>
<span class="sd">        and velocities (m/s) in ECEF reference frame. </span>
<span class="sd">    vsate : ndarray with shape (...,n,3), optional</span>
<span class="sd">        Array with velocities in ECEF reference frame (m/s), only if the input</span>
<span class="sd">        parameter `vsat` is not empty.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The function returns a single ndarray `xsate` with the ECEF state vector when the </span>
<span class="sd">    parameters `xsat` are a state vector (having 6 elements) and `vsat` is empty. When</span>
<span class="sd">    `vsat` is not empty, the function returns two ndarrays.</span>

<span class="sd">    The function returns ndarrays with at least two dimensions.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    ut2gmst, ecef2eci</span>

<span class="sd">    Examples</span>
<span class="sd">    --------    </span>
<span class="sd">    Example with single statevector (note the two dimensional result(s)) </span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; eci2ecef(&#39;2012-01-04 15:00:00&#39;,[-5767701.7786, -3097382.0132, 2737195.4374,  3001.4240, -6762.1059, -1280.2560])</span>
<span class="sd">    array([[-3.31253110e+06, -5.64688382e+06,  2.73719544e+06,</span>
<span class="sd">             5.67077507e+03, -3.96999941e+03, -1.28025600e+03]])</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; eci2ecef(&#39;2012-01-04 15:00:00&#39;,[-5767701.7786, -3097382.0132, 2737195.4374],[ 3001.4240, -6762.1059, -1280.2560])</span>
<span class="sd">    (array([[-3312531.10067826, -5646883.81761125,  2737195.4374    ]]), array([[ 5670.77506798, -3969.99940934, -1280.256     ]]))</span>

<span class="sd">    Two dimensional examples </span>

<span class="sd">    &gt;&gt;&gt; t = np.array([&#39;2012-01-04 15:00:00&#39;, &#39;2012-01-04 16:00:00&#39;, &#39;2012-01-04 17:00:00&#39;, &#39;2012-01-04 18:00:00&#39;], dtype=&#39;datetime64[ns]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; svec = [[-5767701.7786, -3097382.0132, 2737195.4374,  3001.4240, -6762.1059, -1280.2560],</span>
<span class="sd">    ...         [ -625224.3608, -7162713.9833,   16233.9739, -1131.8951,   116.3879,  7358.7436],</span>
<span class="sd">    ...         [-2301220.9378,  6666917.3737,  968353.5303, -6610.7556, -1833.8971, -2992.6557],</span>
<span class="sd">    ...         [-2301220.9378,  6666917.3737,  968353.5303, -6610.7556, -1833.8971, -2992.6557]]</span>
<span class="sd">    &gt;&gt;&gt; eci2ecef(t, svec)</span>
<span class="sd">    array([[-3.31253110e+06, -5.64688382e+06,  2.73719544e+06,</span>
<span class="sd">             5.67077507e+03, -3.96999941e+03, -1.28025600e+03],</span>
<span class="sd">           [ 1.41341049e+06, -7.04965587e+06,  1.62339739e+04,</span>
<span class="sd">            -1.63304150e+03, -3.09546050e+02,  7.35874360e+03],</span>
<span class="sd">           [-2.45011540e+06,  6.61364798e+06,  9.68353530e+05,</span>
<span class="sd">            -6.08570289e+03, -1.80298462e+03, -2.99265570e+03],</span>
<span class="sd">           [-6.49857962e+05,  7.02289753e+06,  9.68353530e+05,</span>
<span class="sd">            -6.34510204e+03, -1.61905582e+02, -2.99265570e+03]])</span>

<span class="sd">    &gt;&gt;&gt; svec_array = np.asarray(svec)</span>
<span class="sd">    &gt;&gt;&gt; xsat = svec_array[:,0:3]</span>
<span class="sd">    &gt;&gt;&gt; vsat = svec_array[:,3:]</span>
<span class="sd">    &gt;&gt;&gt; eci2ecef(t, xsat, vsat)</span>
<span class="sd">    (array([[-3312531.10067826, -5646883.81761125,  2737195.4374    ],</span>
<span class="sd">           [ 1413410.48702954, -7049655.87125032,    16233.9739    ],</span>
<span class="sd">           [-2450115.40038307,  6613647.97952822,   968353.5303    ],</span>
<span class="sd">           [ -649857.96174134,  7022897.52893159,   968353.5303    ]]), array([[ 5670.77506798, -3969.99940934, -1280.256     ],</span>
<span class="sd">           [-1633.0414957 ,  -309.54604979,  7358.7436    ],</span>
<span class="sd">           [-6085.70289335, -1802.98462425, -2992.6557    ],</span>
<span class="sd">           [-6345.10203574,  -161.90558206, -2992.6557    ]]))</span>

<span class="sd">    Check that inverse operation returns the original</span>

<span class="sd">    &gt;&gt;&gt; svece = eci2ecef(t,svec)</span>
<span class="sd">    &gt;&gt;&gt; svec2 = ecef2eci(t, svece)</span>
<span class="sd">    &gt;&gt;&gt; print(np.max(np.abs(svec2-svec)) &lt; 1e-8)</span>
<span class="sd">    True</span>

<span class="sd">    Example with more than two dimensions</span>

<span class="sd">    &gt;&gt;&gt; svece = eci2ecef(t, svec)</span>
<span class="sd">    &gt;&gt;&gt; svece23 = eci2ecef(t,[[svec, svec, svec],[svec, svec, svec]])</span>
<span class="sd">    &gt;&gt;&gt; svece23.shape</span>
<span class="sd">    (2, 3, 4, 6)</span>
<span class="sd">    &gt;&gt;&gt; np.max(np.abs(svece23 - svece), axis=(-1,-2))</span>
<span class="sd">    array([[0., 0., 0.],</span>
<span class="sd">           [0., 0., 0.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Convert input parameters to all numpy arrays</span>
    
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">xsat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">xsat</span><span class="p">)</span>
    <span class="n">vsat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">vsat</span><span class="p">)</span>

    <span class="c1"># Check input arguments</span>
   
    <span class="k">assert</span> <span class="n">xsat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">xsat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span> <span class="p">,</span> <span class="s2">&quot;xsat must have shape (...,3) or (...,6).&quot;</span>
    <span class="k">assert</span> <span class="n">xsat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Second to last dimension of xsat must match the length of the array t.&quot;</span>
    <span class="k">if</span> <span class="n">xsat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
         <span class="k">assert</span> <span class="n">vsat</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;xsat has shape (...,6) and contains also velocities, but then vsat must not be used.&quot;</span>
         <span class="n">vsat</span> <span class="o">=</span> <span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>
    <span class="k">elif</span> <span class="n">vsat</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
         <span class="n">vsat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">xsat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>

    <span class="k">assert</span> <span class="n">vsat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;vsat must have shape (...,3).&quot;</span>
    <span class="k">assert</span> <span class="n">vsat</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="s2">&quot;xsat and vsat must have same shape.&quot;</span>

    <span class="c1"># Compute rotation angle (GMST) around Z-axis</span>
   
    <span class="n">gst</span><span class="p">,</span> <span class="n">omegae</span> <span class="o">=</span> <span class="n">ut2gmst</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="c1"># Rotate satellite positions around z-axis (ECI -&gt; ECEF)</span>

    <span class="n">xsate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">xsat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">xsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span><span class="o">*</span><span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span> <span class="o">*</span> <span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">xsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span> <span class="o">*</span> <span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span> <span class="o">*</span> <span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">xsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    To convert the velocity is more complicated. The velocity in ECEF</span>
<span class="sd">    consists of two parts. We find this by differentiating the transformation</span>
<span class="sd">    formula for the positions</span>

<span class="sd">       xsate = R * xsat</span>

<span class="sd">    This gives (product rule, and some rewriting), with |_dot| the derivatives</span>

<span class="sd">       xsate_dot = R * xsat_dot + R_dot * xsat    &lt;=&gt;</span>
<span class="sd">       vsate = R * ( vsat + inv(R)*R_dot * xsat ) &lt;=&gt;</span>
<span class="sd">       vsate = R * ( vsat + W * xsat )</span>
<span class="sd">    </span>
<span class="sd">    with &#39;W = inv(R)*R_dot = [[ 0, -w[2] w[1]],[ w[2] 0 -w[0]],[-w[1] w[0] 0]]&#39; </span>
<span class="sd">    and with &#39;w&#39; the angular velocity vector of the ECEF frame with respect to</span>
<span class="sd">    the ECI frame, expressed in the ECI frame. </span>
<span class="sd">    </span>
<span class="sd">    For the ECI to ECEF transformation the angular velocity vector is w = [0, 0, -w0]&#39;</span>
<span class="sd">    with &#39;w0=2*np.pi*omegae/86400&#39;, thus &#39;W = [[0, +w0, 0], [-w0, 0, 0], [0, 0, 0]]&#39;, </span>
<span class="sd">    hence &#39;W * xsate = [ w0*xsate[1], -w0*xsate[0], 0 ]&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1"># The velocity vector in the ECEF is computed as follows</span>
    
    <span class="n">w0</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">omegae</span><span class="o">/</span><span class="mi">86400</span>
    <span class="n">h0</span> <span class="o">=</span> <span class="n">vsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">w0</span> <span class="o">*</span> <span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>   
    <span class="n">h1</span> <span class="o">=</span> <span class="n">vsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">w0</span> <span class="o">*</span> <span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>    

    <span class="n">vsate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">vsat</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">vsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span> <span class="o">*</span> <span class="n">h0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span> <span class="o">*</span> <span class="n">h1</span>
    <span class="n">vsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span> <span class="o">*</span> <span class="n">h0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">gst</span><span class="p">)</span> <span class="o">*</span> <span class="n">h1</span>
    <span class="n">vsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">vsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">xsat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span><span class="p">:</span>
        <span class="n">xsate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">3</span><span class="p">:]</span> <span class="o">=</span> <span class="n">vsate</span>
        <span class="k">return</span> <span class="n">xsate</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xsate</span><span class="p">,</span> <span class="n">vsate</span></div>



<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#                      LOOKANGLES</span>
<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1">#   satlookangle    Compute table with satellite look angles</span>
<span class="c1">#   prtlookangle    Print a table with satellite look angles.</span>

<div class="viewcode-block" id="satlookangle">
<a class="viewcode-back" href="../../reference/generated/pymgp.satorb.satlookangle.html#pymgp.satorb.satlookangle">[docs]</a>
<span class="k">def</span> <span class="nf">satlookangle</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">xsat</span><span class="p">,</span> <span class="n">xobj</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">swathdef</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;VIS&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">],</span> <span class="n">ellips</span><span class="o">=</span><span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute table with satellite look angles.</span>
<span class="sd">    </span>
<span class="sd">    Compute a table with lookangles</span>
<span class="sd">    </span>
<span class="sd">    - zenith and azimuth angles to satellite for an object on the Earth or in space,</span>
<span class="sd">    - off-nadir and azimuth angle from satellite to object, the lookangle to the object</span>
<span class="sd">      with resepect to the direction of flight of the satellite, and the heading of</span>
<span class="sd">      angle of the satellite </span>
<span class="sd">    - range and range-rate between object and satellite</span>

<span class="sd">    and flags for visibility, ascending/descending orbit, right/left looking, etc.  </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t : array_like with shape (n,) or scalar, of type datetime64, str or float</span>
<span class="sd">        Universal time as `datetime64` object, ISO date string or sequential date </span>
<span class="sd">        number (days since 1970-01-01).</span>
<span class="sd">    xsat : array_like with shape (...,n,6) </span>
<span class="sd">        Array with satellite state vector with positions (m) and velocities (m/s) </span>
<span class="sd">        in ECEF or ECI reference frame. </span>
<span class="sd">    xobj : array_like with shape (3,), (...,n,3) or (...,n,6)</span>
<span class="sd">        Array with the position of the object for which the lookangles are to be</span>
<span class="sd">        computed. `xobj` is either an array of shape (3,) or (...,n,3) with position(s)</span>
<span class="sd">        in the ECEF reference frame, or an array with shape (...,n,6) for statevectors</span>
<span class="sd">        with position and velocity in an ECEF or ECI referenence frame. `xobj`  and </span>
<span class="sd">        `xsat` must always be in the same reference frame.</span>
<span class="sd">    ellips : list of bool, optional       </span>
<span class="sd">        Choice between ellipsoidal or spherical angles for viewing from respectively</span>
<span class="sd">        object and satellite. True means using ellipsoidal angles. Default is [true, false]</span>
<span class="sd">    swathdef : list, optional        </span>
<span class="sd">        Swathdef is a list with four items defining when a satellite is visible. The</span>
<span class="sd">        list consists of a label, the incidence angle range, and the look direction </span>
<span class="sd">        (right look&#39;RL&#39;, left look &#39;LL&#39; or both &#39;&#39;). </span>
<span class="sd">        Example for SENTINEL-1, with swath names, minimum and maximum incidence</span>
<span class="sd">        angle, right looking </span>
<span class="sd">         </span>
<span class="sd">        &gt;&gt;&gt; swathdef=[[&#39;IW1&#39;, 29.16, 36.59, &#39;RL&#39; ],  </span>
<span class="sd">        ...            &#39;IW2&#39;, 34.77, 41.85, &#39;RL&#39; ],  </span>
<span class="sd">        ...            &#39;IW3&#39;, 40.04, 46.00, &#39;RL&#39; ]]</span>
<span class="sd">                                                                               </span>
<span class="sd">        Default is a 10 deg elevation mask</span>

<span class="sd">        &gt;&gt;&gt; swathdef= [&#39;VIS&#39;, 0.00, 80.00, &#39;&#39;]</span>

<span class="sd">    verbose : int, optional    </span>
<span class="sd">        Verbosity level, possible values are 0 or 1  (default is 0)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lookangles : ndarray of floats with shape (...,n,8)</span>
<span class="sd">        Array with the angles (rad), range (m) and range-rate (m/s)::   </span>

<span class="sd">            0  incidence angle at the object, which is identical to the zenith angle,</span>
<span class="sd">            1  azimuth angle from object to the satellite,</span>
<span class="sd">            2  off-nadir angle at the satellite to the direction of the object,</span>
<span class="sd">            3  azimuth angle at the satellite in the direction of the object,</span>
<span class="sd">            4  look angle in the direction of the object with respect to the flight </span>
<span class="sd">               direction of the satellite, </span>
<span class="sd">            5  azimuth angle of the flight direction of the satellite </span>
<span class="sd">            6  range between satellite and object</span>
<span class="sd">            7  range rate in the line of sight</span>

<span class="sd">    flags : ndarray of str with shape (...,n,3)</span>
<span class="sd">        Array with in the first column a ascending/descending flag ``[&#39;ASC&#39;|&#39;DSC&#39;]``, </span>
<span class="sd">        in the 2nd column the left- or right-looking flag ``[&#39;LL&#39;|&#39;RL&#39;]``, and in the</span>
<span class="sd">        third column the visibility flag ``[&#39;VIS|&#39;&#39;|&lt;swath&gt;]``, whereby the swath name </span>
<span class="sd">        can be set by the optional `swathdef` parameter.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `xsat` and `xobj` must be in the same reference frame: so if `xobj` is a </span>
<span class="sd">    shape (...,3) array in ECEF, then also `xsat` must be in the ECEF reference frame.</span>
<span class="sd">    If `xobj` is a shape (..,6) array then both ECI and ECEF are possible, but the</span>
<span class="sd">    reference frame for `xsat` must be the same as for `xobj`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    prtlookangle, eci2ecef, ecef2eci</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; t = np.array([&#39;2012-01-04 15:00:00&#39;, &#39;2012-01-04 16:00:00&#39;, &#39;2012-01-04 17:00:00&#39;, &#39;2012-01-04 18:00:00&#39;], dtype=&#39;datetime64[ns]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xsat = [[-3312531.1007, -5646883.8176, 2737195.4374,  5670.7751, -3969.9994, -1280.2560 ],</span>
<span class="sd">    ...         [ 1413410.4872, -7049655.8712,   16233.9739, -1633.0415,  -309.5460,  7358.7436 ],</span>
<span class="sd">    ...         [-2450115.4006,  6613647.9795,  968353.5303, -6085.7029, -1802.9846, -2992.6557 ],</span>
<span class="sd">    ...         [ -649857.9621,  7022897.5289,  968353.5303, -6345.1020,  -161.9056, -2992.6557 ]]</span>
<span class="sd">    &gt;&gt;&gt; xobj = [ 3924687.7018, 301132.7660, 5001910.7746]</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; lookangles, flags = satlookangle(t, xsat, xobj, verbose=1)</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">                            Incidence Satellite  Off-Nadir LookAngle LookAngle</span>
<span class="sd">             Satellite Pass     Angle   Azimuth      Angle   Azimuth FlightDir   Heading     Range Rangerate   Flags</span>
<span class="sd">                                (deg)     (deg)      (deg)     (deg)     (deg)     (deg)      (km)    (km/s)</span>
<span class="sd">    2012-01-04T15:00:00.000   132.479   310.847     41.320    30.533   289.102   101.432  9637.695    -1.507   DSC LL </span>
<span class="sd">    2012-01-04T16:00:00.000   129.061   264.759     43.437    38.002    50.729   347.273  9230.254    -3.284   ASC RL </span>
<span class="sd">    2012-01-04T17:00:00.000   133.693    72.462     40.230   323.433   207.920   115.513  9836.440     4.014   DSC LL </span>
<span class="sd">    2012-01-04T18:00:00.000   128.662    84.296     44.263   321.590   206.077   115.513  9076.242     4.408   DSC LL </span>
<span class="sd">    &lt;BLANKLINE&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
 
    <span class="c1"># Convert input parameters to all numpy arrays</span>
    
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">xsat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">xsat</span><span class="p">)</span>
    <span class="n">xobj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">xobj</span><span class="p">)</span>
    
    <span class="c1"># Check input arguments</span>
   
    <span class="k">assert</span> <span class="n">xsat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">6</span> <span class="p">,</span> <span class="s2">&quot;xsat must have shape (...,6).&quot;</span>
    <span class="k">assert</span> <span class="n">xsat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Second to last dimension of xsat must match the length of array t.&quot;</span>
    <span class="k">assert</span> <span class="n">xobj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">xobj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="o">==</span> <span class="mi">6</span><span class="p">,</span> <span class="s2">&quot;xobj must have shape (...,3) or (...,6).&quot;</span>
    <span class="k">assert</span> <span class="n">xobj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">xobj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Second to last dimension of xobj must be one or match the length of array t.&quot;</span>

    <span class="c1"># pad xobj with zeros if necessary</span>
    
    <span class="k">if</span> <span class="n">xobj</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">xobj_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">xobj</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">6</span><span class="p">,))</span>
        <span class="n">xobj_</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">xobj</span>
        <span class="n">xobj</span> <span class="o">=</span> <span class="n">xobj_</span> 
   
    <span class="c1"># Compute position vector from object to satellite, range and rangerate</span>

    <span class="n">xobj2sat</span> <span class="o">=</span> <span class="n">xsat</span> <span class="o">-</span> <span class="n">xobj</span>
    <span class="n">robj2sat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xobj2sat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">rrobj2sat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xobj2sat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span> <span class="o">*</span> <span class="n">xobj2sat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">robj2sat</span>

    <span class="c1"># Compute azimuth and zenith angle from object point of view</span>
        
    <span class="n">robj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xobj</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>     <span class="c1"># range to object (observer)</span>
    <span class="k">if</span> <span class="n">ellips</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>                                        <span class="c1"># normal vector from object (observer) </span>
        <span class="n">plh</span> <span class="o">=</span> <span class="n">xyz2plh</span><span class="p">(</span><span class="n">xobj</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">3</span><span class="p">])</span>                      <span class="c1"># - ellipsoidal</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">plh</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">n0</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">n0</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">n0</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>                                        
        <span class="n">n0</span> <span class="o">=</span> <span class="n">xobj</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="n">robj</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>       <span class="c1"># - spherical </span>
    
    <span class="n">ers</span> <span class="o">=</span> <span class="n">xobj2sat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="o">/</span> <span class="n">robj2sat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>  <span class="c1"># init direction vector from observer to satellite</span>

    <span class="n">ip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n0</span> <span class="o">*</span> <span class="n">ers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">z1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">n0</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ers</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n0</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ers</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">ip</span> <span class="o">*</span> <span class="n">n0</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">ers</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">a1</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">a1</span> <span class="o">%=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="c1"># Compute azimuth and nadir angle from satellite point of view</span>

    <span class="n">rsat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ellips</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>                                      <span class="c1"># normal vector at satellite (inverse nadir vector) </span>
        <span class="n">plh</span> <span class="o">=</span> <span class="n">xyz2plh</span><span class="p">(</span><span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">3</span><span class="p">])</span>                    <span class="c1"># - ellipsoidal</span>
        <span class="n">n0sat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">plh</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">n0sat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">n0sat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">n0sat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">plh</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">n0sat</span> <span class="o">=</span> <span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">3</span><span class="p">]</span><span class="o">/</span><span class="n">rsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>    <span class="c1"># - spherical </span>

    <span class="n">ipsat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n0sat</span><span class="o">*</span><span class="n">ers</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">z2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">ipsat</span><span class="p">)</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">n0sat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">ers</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">n0sat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ers</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">ipsat</span><span class="o">*</span><span class="n">n0sat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">ers</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">a2</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">a2</span> <span class="o">%=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="c1"># compute the heading and look angle from the satellite point of view</span>

    <span class="n">velsat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">evsat</span> <span class="o">=</span> <span class="n">xsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">:]</span> <span class="o">/</span> <span class="n">velsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="n">ipvel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n0sat</span><span class="o">*</span><span class="n">evsat</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">heading</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">n0sat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">evsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n0sat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">evsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">ipvel</span><span class="o">*</span><span class="n">n0sat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">evsat</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">heading</span> <span class="o">+=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">heading</span> <span class="o">%=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>

    <span class="n">lookangle</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">+</span> <span class="n">a2</span> <span class="o">-</span> <span class="n">heading</span><span class="p">)</span> <span class="o">%</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set ascending/descending and look direction flags</span>

<span class="sd">    ASC:  Heading -90 ...  90       RL:  lookangle   0 ... 180     </span>
<span class="sd">    DSC:  Heading  90 ... 270       LL:  lookangle 180 ... 360 </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ASCDSC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;DSC&#39;</span><span class="p">,</span> <span class="s1">&#39;ASC&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">ascdsc</span> <span class="o">=</span> <span class="n">ASCDSC</span><span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">heading</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="p">]</span>

    <span class="n">LOOKDIR</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s1">&#39;RL&#39;</span><span class="p">,</span> <span class="s1">&#39;LL&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">lookdir</span> <span class="o">=</span> <span class="n">LOOKDIR</span><span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">lookangle</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="p">]</span>
   
    <span class="c1"># Convert swatchdef from list to 2D numpy array</span>
    <span class="n">swathdef</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">swathdef</span><span class="p">)</span>
    <span class="n">swathdef</span> <span class="o">=</span> <span class="n">swathdef</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">swathdef</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># Set swath definition flag</span>

    <span class="n">IW</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">z1</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;U12&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">sw</span> <span class="ow">in</span> <span class="n">swathdef</span><span class="p">:</span>
        <span class="n">swbool</span> <span class="o">=</span> <span class="p">(</span> <span class="n">z1</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">&gt;=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sw</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">z1</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">&lt;=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sw</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="p">)</span> 
        <span class="k">if</span> <span class="n">sw</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">swbool</span> <span class="o">=</span> <span class="n">swbool</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">lookdir</span> <span class="o">==</span> <span class="n">sw</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">)</span> 
        <span class="n">IW</span><span class="p">[</span><span class="n">swbool</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">IW</span><span class="p">[</span><span class="n">swbool</span><span class="p">],</span><span class="s1">&#39;&amp;&#39;</span> <span class="o">+</span> <span class="n">sw</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">IW</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">char</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="n">IW</span><span class="p">,</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>

    <span class="c1"># Collect output</span>
    
    <span class="n">lookangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">z1</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">8</span><span class="p">,))</span>
    <span class="n">lookangles</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">z1</span>
    <span class="n">lookangles</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">a1</span>
    <span class="n">lookangles</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z2</span>
    <span class="n">lookangles</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">a2</span>
    <span class="n">lookangles</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">lookangle</span>
    <span class="n">lookangles</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">heading</span>
    <span class="n">lookangles</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">robj2sat</span>
    <span class="n">lookangles</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span> <span class="o">=</span> <span class="n">rrobj2sat</span>

    <span class="n">flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">z1</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
    <span class="n">flags</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ascdsc</span>
    <span class="n">flags</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lookdir</span>
    <span class="n">flags</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">IW</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">prtlookangle</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">lookangles</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">lookangles</span><span class="p">,</span> <span class="n">flags</span></div>




<div class="viewcode-block" id="prtlookangle">
<a class="viewcode-back" href="../../reference/generated/pymgp.satorb.prtlookangle.html#pymgp.satorb.prtlookangle">[docs]</a>
<span class="k">def</span> <span class="nf">prtlookangle</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">lookangles</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">titlestr</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">tableformat</span><span class="o">=</span><span class="s1">&#39;default&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Print a table with satellite look angles.</span>
<span class="sd"> </span>
<span class="sd">    Print a table with zenith and azimuth angles to satellite, off-nadir, azimuth and</span>
<span class="sd">    lookangle from satellite, satellite heading, range, range-rate, and flags for </span>
<span class="sd">    visibility, ascending/descending orbit, right/left looking.  </span>
<span class="sd">    </span>
<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    t : array_like with shape (n,) or scalar, of type datetime64, str or float</span>
<span class="sd">        Universal time as `datetime64` object, ISO date string or sequential date </span>
<span class="sd">        number (days since 1970-01-01).</span>
<span class="sd">    lookangles : array_like of floats with shape (...,n,8)</span>
<span class="sd">        Array with the angles (rad), range (m) and range-rate (m/s)::   </span>

<span class="sd">            0  incidence angle at the object, which is identical to the zenith angle,</span>
<span class="sd">            1  azimuth angle from object to the satellite,</span>
<span class="sd">            2  off-nadir angle at the satellite to the direction of the object,</span>
<span class="sd">            3  azimuth angle at the satellite in the direction of the object,</span>
<span class="sd">            4  look angle in the direction of the object with respect to the flight </span>
<span class="sd">               direction of the satellite, </span>
<span class="sd">            5  azimuth angle of the flight direction of the satellite </span>
<span class="sd">            6  range between satellite and object</span>
<span class="sd">            7  range rate in the line of sight</span>

<span class="sd">    flags : array_like of str with shape (...,n,3)</span>
<span class="sd">        Array with in the first column a ascending/descending flag ``[&#39;ASC&#39;|&#39;DSC&#39;]``, </span>
<span class="sd">        in the 2nd column the left- or right-looking flag ``[&#39;LL&#39;|&#39;RL&#39;]``, and in the</span>
<span class="sd">        third column the visibility flag ``[&#39;VIS|&#39;&#39;|&lt;swath&gt;]``.</span>
<span class="sd">    titlestr : str or list of str, optional</span>
<span class="sd">        Title string. Use a list for 3- or more dimensional cases of `lookangles`,</span>
<span class="sd">        with shape matching dimensions above 2. </span>
<span class="sd">    tableformat :  {&#39;default&#39;, &#39;ers&#39;}, optional</span>
<span class="sd">        Table format. The &#39;default&#39; is &#39;ers&#39;.</span>

<span class="sd">    See Also </span>
<span class="sd">    --------</span>
<span class="sd">    satlookangle   </span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; t = np.array([&#39;2012-01-04 15:00:00&#39;, &#39;2012-01-04 16:00:00&#39;, &#39;2012-01-04 17:00:00&#39;, &#39;2012-01-04 18:00:00&#39;], dtype=&#39;datetime64[ns]&#39;)</span>
<span class="sd">    &gt;&gt;&gt; xsat = [[-3312531.1007, -5646883.8176, 2737195.4374,  5670.7751, -3969.9994, -1280.2560 ],</span>
<span class="sd">    ...         [ 1413410.4872, -7049655.8712,   16233.9739, -1633.0415,  -309.5460,  7358.7436 ],</span>
<span class="sd">    ...         [-2450115.4006,  6613647.9795,  968353.5303, -6085.7029, -1802.9846, -2992.6557 ],</span>
<span class="sd">    ...         [ -649857.9621,  7022897.5289,  968353.5303, -6345.1020,  -161.9056, -2992.6557 ]]</span>
<span class="sd">    &gt;&gt;&gt; xobj = [ 3924687.7018, 301132.7660, 5001910.7746]</span>
<span class="sd">    </span>
<span class="sd">    &gt;&gt;&gt; lookangles, flags = satlookangle(t, xsat, xobj)</span>
<span class="sd">    &gt;&gt;&gt; prtlookangle(t, lookangles, flags)</span>
<span class="sd">    &lt;BLANKLINE&gt;</span>
<span class="sd">                            Incidence Satellite  Off-Nadir LookAngle LookAngle</span>
<span class="sd">             Satellite Pass     Angle   Azimuth      Angle   Azimuth FlightDir   Heading     Range Rangerate   Flags</span>
<span class="sd">                                (deg)     (deg)      (deg)     (deg)     (deg)     (deg)      (km)    (km/s)</span>
<span class="sd">    2012-01-04T15:00:00.000   132.479   310.847     41.320    30.533   289.102   101.432  9637.695    -1.507   DSC LL </span>
<span class="sd">    2012-01-04T16:00:00.000   129.061   264.759     43.437    38.002    50.729   347.273  9230.254    -3.284   ASC RL </span>
<span class="sd">    2012-01-04T17:00:00.000   133.693    72.462     40.230   323.433   207.920   115.513  9836.440     4.014   DSC LL </span>
<span class="sd">    2012-01-04T18:00:00.000   128.662    84.296     44.263   321.590   206.077   115.513  9076.242     4.408   DSC LL </span>
<span class="sd">    &lt;BLANKLINE&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Convert input parameters to all numpy arrays</span>
    
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">lookangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">lookangles</span><span class="p">)</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>

    <span class="c1"># For arrays with dimension higher than 2 call this function recursively</span>
    
    <span class="k">if</span> <span class="n">lookangles</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">titlestr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">titlestr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lookangles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">titlestr</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">subtitle</span> <span class="o">=</span> <span class="n">titlestr</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">subtitle</span> <span class="o">=</span> <span class="n">titlestr</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="o">...</span><span class="p">]</span>
            <span class="n">prtlookangle</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">lookangles</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="n">flags</span><span class="p">[</span><span class="n">k</span><span class="p">,</span><span class="o">...</span><span class="p">],</span> <span class="n">titlestr</span><span class="o">=</span><span class="n">subtitle</span><span class="p">,</span><span class="n">tableformat</span><span class="o">=</span><span class="n">tableformat</span><span class="p">)</span>
        <span class="k">return</span>
        
    <span class="c1"># Check input arguments</span>
   
    <span class="k">assert</span> <span class="n">lookangles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">,</span> <span class="s2">&quot;lookangles must have shape (...,8).&quot;</span>
    <span class="k">assert</span> <span class="n">flags</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">,</span> <span class="s2">&quot;flags must have shape (...,3).&quot;</span>
    <span class="k">assert</span> <span class="n">lookangles</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Second to last dimension of lookangles must match the length of array t.&quot;</span>
    <span class="k">assert</span> <span class="n">flags</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>  <span class="o">==</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="s2">&quot;Second to last dimension of flags must match the length of array t.&quot;</span>
    <span class="k">assert</span> <span class="n">lookangles</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">],</span> <span class="s2">&quot;Lookangles must be a numeric array.&quot;</span>

    <span class="k">assert</span> <span class="n">tableformat</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="s1">&#39;ers&#39;</span><span class="p">],</span> <span class="sa">f</span><span class="s2">&quot;Unsupported table format </span><span class="si">{</span><span class="n">tableformat</span><span class="si">}</span><span class="s2">.&quot;</span>

    <span class="c1"># If time not datetime64, convert from sequential date number </span>
   
    <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;1970-01-01&#39;</span><span class="p">,</span> <span class="s1">&#39;ms&#39;</span><span class="p">)</span>  <span class="o">+</span> <span class="n">t</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">86400000</span><span class="p">,</span> <span class="s1">&#39;ms&#39;</span><span class="p">)</span> 
    
    <span class="c1"># Print optional title</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">titlestr</span><span class="p">,</span> <span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">titlestr</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="k">else</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">))</span>
    
    <span class="c1"># Print table</span>
    
    <span class="k">if</span> <span class="n">tableformat</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">,</span> <span class="s1">&#39;ers&#39;</span><span class="p">]:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;                        Incidence Satellite  Off-Nadir LookAngle LookAngle&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;         Satellite Pass     Angle   Azimuth      Angle   Azimuth FlightDir   Heading     Range Rangerate&#39;</span>
              <span class="s1">&#39;   Flags&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;                            (deg)     (deg)      (deg)     (deg)     (deg)     (deg)      (km)    (km/s)&#39;</span>
              <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">isodate</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;datetime64[ms]&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{:&gt;9.3f}</span><span class="s2"> </span><span class="si">{:&gt;9.3f}</span><span class="s2">  </span><span class="si">{:&gt;9.3f}</span><span class="s2"> </span><span class="si">{:&gt;9.3f}</span><span class="s2"> </span><span class="si">{:&gt;9.3f}</span><span class="s2"> </span><span class="si">{:&gt;9.3f}</span><span class="s2"> </span><span class="si">{:&gt;9.3f}</span><span class="s2"> </span><span class="si">{:&gt;9.3f}</span><span class="s2">   </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">isodate</span><span class="p">,</span> <span class="n">lookangles</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">lookangles</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">lookangles</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
                <span class="n">lookangles</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">lookangles</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">lookangles</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">*</span> <span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
                <span class="n">lookangles</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">lookangles</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">flags</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">flags</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">flags</span><span class="p">[</span><span class="n">k</span><span class="p">,</span> <span class="mi">2</span><span class="p">]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span></div>


<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#                         SERIAL DATE NUMBERS</span>
<span class="c1"># ----------------------------------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1">#  datetime2num   Convert datestring, datetime or np.datetime64 to serial datenumber</span>
<span class="c1">#  num2datetime64 Convert serial datenumber to np.datetime64</span>
<span class="c1">#  num2datetime   Convert serial datenumber to datetime</span>

<div class="viewcode-block" id="datetime2num">
<a class="viewcode-back" href="../../reference/generated/pymgp.satorb.datetime2num.html#pymgp.satorb.datetime2num">[docs]</a>
<span class="k">def</span> <span class="nf">datetime2num</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert array wtih np.datetime64 objects to serial datenumber (float, days since 01-01-1970 00:00).&quot;&quot;&quot;</span> 
    <span class="n">t64</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;datetime64&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span> <span class="n">t64</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;1970-01-01&#39;</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="num2datetime64">
<a class="viewcode-back" href="../../reference/generated/pymgp.satorb.num2datetime64.html#pymgp.satorb.num2datetime64">[docs]</a>
<span class="k">def</span> <span class="nf">num2datetime64</span><span class="p">(</span><span class="n">datenum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert array with serial datenumbers (float, days since 01-01-1970 00:00) to np.datetime64 objects.&quot;&quot;&quot;</span> 
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s1">&#39;1970-01-01&#39;</span><span class="p">,</span> <span class="s1">&#39;ms&#39;</span><span class="p">)</span>  <span class="o">+</span> <span class="n">datenum</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="mi">86400000</span><span class="p">,</span> <span class="s1">&#39;ms&#39;</span><span class="p">)</span>    </div>


<div class="viewcode-block" id="num2datetime">
<a class="viewcode-back" href="../../reference/generated/pymgp.satorb.num2datetime.html#pymgp.satorb.num2datetime">[docs]</a>
<span class="k">def</span> <span class="nf">num2datetime</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert array with serial datenumbers (float, days since 01-01-1970 00:00) to datetime objects.&quot;&quot;&quot;</span> 
    <span class="k">return</span> <span class="n">num2datetime64</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">datetime</span><span class="p">)</span></div>

        
</pre></div>

                </article>
              
              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
          </footer>
        
      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=8878045cc6db502f8baf"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=8878045cc6db502f8baf"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
  
    <div class="footer-items__start">
      
        <div class="footer-item">

  <p class="copyright">
    
       Copyright 2025, Hans van der Marel.
      <br/>
    
  </p>
</div>
      
        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3.
    <br/>
  </p>
</div>
      
    </div>
  
  
  
    <div class="footer-items__end">
      
        <div class="footer-item">
<p class="theme-version">
  <!-- # L10n: Setting the PST URL as an argument as this does not need to be localized -->
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.16.1.
</p></div>
      
    </div>
  
</div>

  </footer>
  </body>
</html>